{
  "repo_name": "ChatIQ",
  "total_chunks": 256,
  "total_files": 9,
  "embedding_dimension": 384,
  "chunking_time_seconds": 0.24,
  "chunks": [
    {
      "index": 0,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "0",
      "text": "import re\nfrom collections import Counter\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport streamlit as st\nimport matplotlib.pyplot as plt\nimport urlextract\nimport emoji\nfrom wordcloud import WordCloud\nfrom sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer\nfrom sklearn.decomposition import LatentDirichletAllocation, NMF\nfrom sklearn.cluster import KMeans\nfrom sklearn.metrics import silhouette_score\nfrom sklearn.preprocessing import StandardScaler\nfrom textblob import TextBlob\nimport nltk\nimport os\nnltk.download('punkt')\n# Manually set NLTK data path\nnltk.data.path.append(r\"C:\\Users\\asus\\AppData\\Roaming\\nltk_data\")"
    },
    {
      "index": 1,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "1",
      "text": "')\n# Manually set NLTK data path\nnltk.data.path.append(r\"C:\\Users\\asus\\AppData\\Roaming\\nltk_data\")\n\n# Verify if punkt is found\nprint(nltk.data.find('tokenizers/punkt'))  # This should print the correct path\nimport nltk\nfrom nltk.tokenize import word_tokenize\nfrom nltk.corpus import stopwords\n\n\n\n\n# Download NLTK resources\ntry:\n    nltk.data.find('tokenizers/punkt')\nexcept LookupError:\n    nltk.download('punkt', quiet=True)\ntry:\n    nltk.data.find('corpora/stopwords')\nexcept LookupError:\n    nltk.download('stopwords', quiet=True)"
    },
    {
      "index": 2,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "2",
      "text": "ltk.data.find('corpora/stopwords')\nexcept LookupError:\n    nltk.download('stopwords', quiet=True)\n\n\ndef generateDataFrame(file):\n    \"\"\"Generate DataFrame from WhatsApp chat export file\"\"\"\n    data = file.read().decode(\"utf-8\")\n    data = data.replace('\\u202f', ' ')\n    data = data.replace('\\n', ' ')\n    dt_format = '\\d{1,2}/\\d{1,2}/\\d{2,4},\\s\\d{1,2}:\\d{2}\\s?(?:AM\\s|PM\\s|am\\s|pm\\s)?-\\s'\n    msgs = re.split(dt_format, data)[1:]\n    date_times = re.findall(dt_format, data)\n    date = []\n    time = []\n    for dt in date_times:\n        date.append(re.search('\\d{1,2}/\\d{1,2}/\\d{2,4}', dt).group())\n        time.append(re.search('\\d{1,2}:\\d{2}\\s?(?:AM|PM|am|pm)?', dt).group())\n    users = []\n    message = []\n    for m in msgs:\n        s = re.split('([\\w\\W]+?):\\s', m)\n        if (len(s) < 3):"
    },
    {
      "index": 3,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "3",
      "text": "message = []\n    for m in msgs:\n        s = re.split('([\\w\\W]+?):\\s', m)\n        if (len(s) < 3):\n            users.append(\"Notifications\")\n            message.append(s[0])\n        else:\n            users.append(s[1])\n            message.append(s[2])\n    df = pd.DataFrame(list(zip(date, time, users, message)), columns=[\"Date\", \"Time(U)\", \"User\", \"Message\"])\n    return df\n\n\ndef getUsers(df):\n    \"\"\"Extract unique users from DataFrame\"\"\"\n    users = df['User'].unique().tolist()\n    users.sort()\n    users.remove('Notifications')\n    users.insert(0, 'Everyone')\n    return users"
    },
    {
      "index": 4,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "4",
      "text": "users.sort()\n    users.remove('Notifications')\n    users.insert(0, 'Everyone')\n    return users\n\n\ndef PreProcess(df, dayfirst):\n    \"\"\"Preprocess DataFrame with date and time features\"\"\"\n    df['Date'] = pd.to_datetime(df['Date'], dayfirst=dayfirst)\n    df['Time'] = pd.to_datetime(df['Time(U)']).dt.time\n    df['year'] = df['Date'].apply(lambda x: int(str(x)[:4]))\n    df['month'] = df['Date'].apply(lambda x: int(str(x)[5:7]))\n    df['date'] = df['Date'].apply(lambda x: int(str(x)[8:10]))\n    df['day'] = df['Date'].apply(lambda x: x.day_name())\n    df['hour'] = df['Time'].apply(lambda x: int(str(x)[:2]))\n    df['month_name'] = df['Date'].apply(lambda x: x.month_name())\n    \n    # Add day_type feature: Weekday or Weekend"
    },
    {
      "index": 5,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "5",
      "text": "'] = df['Date'].apply(lambda x: x.month_name())\n    \n    # Add day_type feature: Weekday or Weekend\n    df['day_type'] = df['day'].apply(lambda x: 'Weekend' if x in ['Saturday', 'Sunday'] else 'Weekday')\n    \n    # Add time_of_day feature\n    df['time_of_day'] = df['hour'].apply(categorize_time_of_day)\n    \n    return df\n\n\ndef categorize_time_of_day(hour):\n    \"\"\"Categorize hour into time of day\"\"\"\n    if 5 <= hour < 12:\n        return 'Morning'\n    elif 12 <= hour < 17:\n        return 'Afternoon'\n    elif 17 <= hour < 21:\n        return 'Evening'\n    else:\n        return 'Night'"
    },
    {
      "index": 6,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "6",
      "text": "n 'Afternoon'\n    elif 17 <= hour < 21:\n        return 'Evening'\n    else:\n        return 'Night'\n\n\ndef getStats(df):\n    \"\"\"Get statistics from DataFrame\"\"\"\n    media = df[df['Message'] == \"<Media omitted> \"]\n    media_cnt = media.shape[0]\n    df.drop(media.index, inplace=True)\n    \n    deleted_msgs = df[df['Message'] == \"This message was deleted \"]\n    deleted_msgs_cnt = deleted_msgs.shape[0]\n    df.drop(deleted_msgs.index, inplace=True)\n    \n    temp = df[df['User'] == 'Notifications']\n    df.drop(temp.index, inplace=True)\n    \n    # Extract links\n    extractor = urlextract.URLExtract()\n    links = []\n    for msg in df['Message']:\n        x = extractor.find_urls(msg)\n        if x:\n            links.extend(x)\n    links_cnt = len(links)\n    \n    # Count words\n    word_list = []"
    },
    {
      "index": 7,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "7",
      "text": "x:\n            links.extend(x)\n    links_cnt = len(links)\n    \n    # Count words\n    word_list = []\n    for msg in df['Message']:\n        word_list.extend(msg.split())\n    word_count = len(word_list)\n    \n    msg_count = df.shape[0]\n    \n    # Calculate average message length\n    df['message_length'] = df['Message'].apply(len)\n    avg_msg_length = round(df['message_length'].mean(), 2)\n    \n    return df, media_cnt, deleted_msgs_cnt, links_cnt, word_count, msg_count, avg_msg_length\n\n\ndef getEmoji(df):\n    \"\"\"Extract and count emojis from messages\"\"\"\n    emojis = []\n    for message in df['Message']:\n        emojis.extend([c for c in message if c in emoji.EMOJI_DATA])\n    return pd.DataFrame(Counter(emojis).most_common(len(Counter(emojis))))"
    },
    {
      "index": 8,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "8",
      "text": "in emoji.EMOJI_DATA])\n    return pd.DataFrame(Counter(emojis).most_common(len(Counter(emojis))))\n\n\ndef getMonthlyTimeline(df):\n    \"\"\"Get monthly timeline of messages\"\"\"\n    df.columns = df.columns.str.strip()\n    df=df.reset_index()\n    timeline = df.groupby(['year', 'month']).count()['Message'].reset_index()\n    time = []\n    for i in range(timeline.shape[0]):\n        time.append(str(timeline['month'][i]) + \"-\" + str(timeline['year'][i]))\n    timeline['time'] = time\n    return timeline"
    },
    {
      "index": 9,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "9",
      "text": "ne['month'][i]) + \"-\" + str(timeline['year'][i]))\n    timeline['time'] = time\n    return timeline\n\n\ndef MostCommonWords(df, top_n=20):\n    \"\"\"Get most common words used in chat\"\"\"\n    stop_words_list = set(stopwords.words('english'))\n    \n    try:\n        f = open('stop_hinglish.txt')\n        custom_stop_words = f.read()\n        f.close()\n        \n        # Combine both stopword lists\n        for word in custom_stop_words.split():\n            stop_words_list.add(word.lower())\n    except:\n        pass\n    \n    words = []\n    for message in df['Message']:\n        for word in message.lower().split():\n            if word not in stop_words_list and len(word) > 2:\n                words.append(word)\n    \n    return pd.DataFrame(Counter(words).most_common(top_n))"
    },
    {
      "index": 10,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "10",
      "text": "words.append(word)\n    \n    return pd.DataFrame(Counter(words).most_common(top_n))\n\n\ndef dailytimeline(df):\n    \"\"\"Plot daily timeline of messages\"\"\"\n    df['taarek'] = df['Date']\n    daily_timeline = df.groupby('taarek').count()['Message'].reset_index()\n    \n    # Calculate 7-day rolling average\n    daily_timeline['Rolling_Average'] = daily_timeline['Message'].rolling(window=7).mean()\n    \n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.plot(daily_timeline['taarek'], daily_timeline['Message'], label='Daily Messages', alpha=0.7)\n    ax.plot(daily_timeline['taarek'], daily_timeline['Rolling_Average'], \n            color='red', linewidth=2, label='7-day Rolling Average')\n    ax.set_ylabel(\"Messages Sent\")\n    ax.set_xlabel(\"Date\")"
    },
    {
      "index": 11,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "11",
      "text": "idth=2, label='7-day Rolling Average')\n    ax.set_ylabel(\"Messages Sent\")\n    ax.set_xlabel(\"Date\")\n    ax.grid(True, linestyle='--', alpha=0.7)\n    ax.legend()\n    plt.xticks(rotation=45)\n    plt.tight_layout()\n    st.title('Daily Timeline with Trend Analysis')\n    st.pyplot(fig)"
    },
    {
      "index": 12,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "12",
      "text": "=45)\n    plt.tight_layout()\n    st.title('Daily Timeline with Trend Analysis')\n    st.pyplot(fig)\n\n\ndef WeekAct(df):\n    \"\"\"Plot weekly activity\"\"\"\n    weekday_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    day_counts = df['day'].value_counts().reindex(weekday_order)\n    \n    fig, ax = plt.subplots(figsize=(10, 6))\n    bars = ax.bar(day_counts.index, day_counts.values, color=sns.color_palette(\"viridis\", 7))\n    ax.set_xlabel(\"Days of Week\")\n    ax.set_ylabel(\"Messages Sent\")\n    ax.grid(True, linestyle='--', alpha=0.3, axis='y')\n    \n    # Add data labels\n    for bar in bars:\n        height = bar.get_height()\n        ax.text(bar.get_x() + bar.get_width()/2., height + 5,\n                f'{height}', ha='center', va='bottom')"
    },
    {
      "index": 13,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "13",
      "text": "t_x() + bar.get_width()/2., height + 5,\n                f'{height}', ha='center', va='bottom')\n    \n    plt.tight_layout()\n    st.pyplot(fig)"
    },
    {
      "index": 14,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "14",
      "text": "f'{height}', ha='center', va='bottom')\n    \n    plt.tight_layout()\n    st.pyplot(fig)\n\n\ndef MonthAct(df):\n    \"\"\"Plot monthly activity\"\"\"\n    month_order = ['January', 'February', 'March', 'April', 'May', 'June', \n                  'July', 'August', 'September', 'October', 'November', 'December']\n    month_counts = df['month_name'].value_counts().reindex(month_order)\n    \n    fig, ax = plt.subplots(figsize=(10, 6))\n    bars = ax.bar(month_counts.index, month_counts.values, color=sns.color_palette(\"magma\", 12))\n    ax.set_xlabel(\"Months\")\n    ax.set_ylabel(\"Messages Sent\")\n    ax.grid(True, linestyle='--', alpha=0.3, axis='y')\n    \n    # Add data labels\n    for bar in bars:\n        height = bar.get_height()\n        ax.text(bar.get_x() + bar.get_width()/2., height + 5,"
    },
    {
      "index": 15,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "15",
      "text": "rs:\n        height = bar.get_height()\n        ax.text(bar.get_x() + bar.get_width()/2., height + 5,\n                f'{height}', ha='center', va='bottom')\n    \n    plt.xticks(rotation=45)\n    plt.tight_layout()\n    st.pyplot(fig)\n\n\ndef activity_heatmap(df):\n    \"\"\"Create heatmap of activity by day and hour\"\"\"\n    period = []\n    for hour in df[['day', 'hour']]['hour']:\n        if hour == 23:\n            period.append(str(hour) + \"-\" + str('00'))\n        elif hour == 0:\n            period.append(str('00') + \"-\" + str(hour + 1))\n        else:\n            period.append(str(hour) + \"-\" + str(hour + 1))"
    },
    {
      "index": 16,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "16",
      "text": "') + \"-\" + str(hour + 1))\n        else:\n            period.append(str(hour) + \"-\" + str(hour + 1))\n\n    df['period'] = period\n    \n    # Reorder days of week\n    day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    \n    user_heatmap = df.pivot_table(index='day', columns='period', values='Message', \n                                 aggfunc='count').fillna(0)\n    \n    # Reindex to ensure correct day order\n    user_heatmap = user_heatmap.reindex(day_order)\n    \n    return user_heatmap\n\n\ndef create_wordcloud(df):"
    },
    {
      "index": 17,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "17",
      "text": "heatmap = user_heatmap.reindex(day_order)\n    \n    return user_heatmap\n\n\ndef create_wordcloud(df):\n\n    stop_words_list = set(stopwords.words('english'))\n    \n    try:\n        f = open('stop_hinglish.txt', 'r')\n        custom_stop_words = f.read()\n        f.close()\n        \n       \n        for word in custom_stop_words.split():\n            stop_words_list.add(word.lower())\n    except:\n        pass\n    \n    def remove_stop_words(message):\n        y = []\n        for word in message.lower().split():\n            if word not in stop_words_list and len(word) > 2:\n                y.append(word)\n        return \" \".join(y)"
    },
    {
      "index": 18,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "18",
      "text": "ot in stop_words_list and len(word) > 2:\n                y.append(word)\n        return \" \".join(y)\n\n    wc = WordCloud(width=800, height=400, min_font_size=10, background_color='white',\n                  colormap='viridis', contour_width=1, contour_color='steelblue')\n    df['Message'] = df['Message'].apply(remove_stop_words)\n    df_wc = wc.generate(df['Message'].str.cat(sep=\" \"))\n    return df_wc\n\n\ndef sentiment_analysis(df):\n\n    def get_sentiment(text):\n        analysis = TextBlob(text)\n        \n        return analysis.sentiment.polarity\n\n    df['sentiment_score'] = df['Message'].apply(get_sentiment)"
    },
    {
      "index": 19,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "19",
      "text": "return analysis.sentiment.polarity\n\n    df['sentiment_score'] = df['Message'].apply(get_sentiment)\n\n    def categorize_sentiment(score):\n        if score > 0.1:\n            return 'Positive'\n        elif score < -0.1:\n            return 'Negative'\n        else:\n            return 'Neutral'\n    \n    df['sentiment'] = df['sentiment_score'].apply(categorize_sentiment)\n    \n    user_sentiment = df.groupby('User')['sentiment_score'].mean().sort_values(ascending=False)\n \n    sentiment_counts = df['sentiment'].value_counts()\n\n    sentiment_over_time = df.groupby(['Date'])['sentiment_score'].mean().reset_index()\n    sentiment_over_time['Rolling_Avg'] = sentiment_over_time['sentiment_score'].rolling(window=7).mean()\n    \n    return df, user_sentiment, sentiment_counts, sentiment_over_time"
    },
    {
      "index": 20,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "20",
      "text": "olling(window=7).mean()\n    \n    return df, user_sentiment, sentiment_counts, sentiment_over_time\n\n\ndef topic_modeling(df, num_topics=5):\n    user_messages = df.groupby('User')['Message'].apply(' '.join).reset_index()\n    vectorizer = CountVectorizer(\n        stop_words='english', \n        min_df=2,  \n        max_df=0.9 \n    )\n    \n    if len(user_messages) < num_topics:\n        num_topics = max(2, len(user_messages) - 1)\n    \n    try:\n        dtm = vectorizer.fit_transform(user_messages['Message'])\n        feature_names = vectorizer.get_feature_names_out()\n\n        lda_model = LatentDirichletAllocation(\n            n_components=num_topics,\n            random_state=42,\n            max_iter=20\n        )\n        lda_output = lda_model.fit_transform(dtm)"
    },
    {
      "index": 21,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "21",
      "text": "ndom_state=42,\n            max_iter=20\n        )\n        lda_output = lda_model.fit_transform(dtm)\n\n        topic_words = {}\n        for topic_idx, topic in enumerate(lda_model.components_):\n            top_words_idx = topic.argsort()[:-11:-1]  \n            top_words = [feature_names[i] for i in top_words_idx]\n            topic_words[f\"Topic {topic_idx+1}\"] = top_words\n\n        user_messages['Dominant_Topic'] = lda_output.argmax(axis=1) + 1\n        user_topic_df = pd.concat([user_messages['User'], \n                                  pd.DataFrame(lda_output, \n                                             columns=[f'Topic_{i+1}' for i in range(num_topics)])], \n                                 axis=1)\n        return topic_words, user_topic_df\n    except:\n        return None, None"
    },
    {
      "index": 22,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "22",
      "text": "axis=1)\n        return topic_words, user_topic_df\n    except:\n        return None, None\n\n\ndef user_clustering(df):\n    \"\"\"Perform clustering to identify user groups\"\"\"\n    # Create features for each user\n    user_stats = df.groupby('User').agg({\n        'Message': 'count',\n        'message_length': 'mean',\n        'sentiment_score': 'mean',\n        'hour': 'mean'\n    }).reset_index()\n    \n    # Add feature for percentage of messages sent on weekends\n    weekend_pct = df[df['day_type'] == 'Weekend'].groupby('User').size() / df.groupby('User').size()\n    user_stats['weekend_pct'] = weekend_pct\n    \n    # Fill NaN values\n    user_stats = user_stats.fillna(0)\n    \n    # For clustering, exclude the 'User' column and scale the features\n    features = user_stats.drop('User', axis=1)"
    },
    {
      "index": 23,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "23",
      "text": "ng, exclude the 'User' column and scale the features\n    features = user_stats.drop('User', axis=1)\n    scaler = StandardScaler()\n    scaled_features = scaler.fit_transform(features)\n    \n    # Determine optimal number of clusters\n    n_clusters_range = range(2, min(6, len(user_stats) - 1)) if len(user_stats) > 3 else [2]\n    silhouette_scores = []\n    \n    try:\n        for n_clusters in n_clusters_range:\n            clusterer = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)\n            cluster_labels = clusterer.fit_predict(scaled_features)\n            silhouette_avg = silhouette_score(scaled_features, cluster_labels)\n            silhouette_scores.append(silhouette_avg)\n        \n        # Choose the number of clusters with the highest silhouette score"
    },
    {
      "index": 24,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "24",
      "text": "(silhouette_avg)\n        \n        # Choose the number of clusters with the highest silhouette score\n        optimal_clusters = n_clusters_range[silhouette_scores.index(max(silhouette_scores))]\n        \n        # Perform final clustering with optimal number of clusters\n        kmeans = KMeans(n_clusters=optimal_clusters, random_state=42, n_init=10)\n        user_stats['Cluster'] = kmeans.fit_predict(scaled_features)\n        \n        # Get cluster centers and interpret\n        centers = scaler.inverse_transform(kmeans.cluster_centers_)\n        \n        # Create descriptions for clusters\n        cluster_descriptions = []\n        for i, center in enumerate(centers):\n            desc = f\"Cluster {i+1}: \"\n            if center[0] > features['Message'].mean():"
    },
    {
      "index": 25,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "25",
      "text": "ters):\n            desc = f\"Cluster {i+1}: \"\n            if center[0] > features['Message'].mean():\n                desc += \"Frequent messengers\"\n            else:\n                desc += \"Occasional messengers\"\n            \n            if center[1] > features['message_length'].mean():\n                desc += \", verbose\"\n            else:\n                desc += \", concise\"\n            \n            if center[2] > features['sentiment_score'].mean():\n                desc += \", positive tone\"\n            elif center[2] < features['sentiment_score'].mean():\n                desc += \", negative tone\"\n            else:\n                desc += \", neutral tone\"\n            \n            if center[3] < 12:\n                desc += \", morning preference\"\n            elif center[3] < 17:"
    },
    {
      "index": 26,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "26",
      "text": "if center[3] < 12:\n                desc += \", morning preference\"\n            elif center[3] < 17:\n                desc += \", afternoon preference\"\n            elif center[3] < 21:\n                desc += \", evening preference\"\n            else:\n                desc += \", night preference\"\n            \n            if center[4] > 0.5:\n                desc += \", weekend active\"\n            else:\n                desc += \", weekday active\"\n            \n            cluster_descriptions.append(desc)\n        \n        return user_stats, cluster_descriptions\n    except:\n        # If clustering fails, return original user_stats without clustering\n        user_stats['Cluster'] = 0\n        return user_stats, [\"Unable to perform meaningful clustering\"]"
    },
    {
      "index": 27,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "27",
      "text": "user_stats['Cluster'] = 0\n        return user_stats, [\"Unable to perform meaningful clustering\"]\n\n\ndef get_user_personality(df, user):\n    \"\"\"Generate a simple personality analysis based on user's messaging patterns\"\"\"\n    if user == \"Everyone\":\n        return None\n    \n    user_df = df[df['User'] == user]\n    \n    if len(user_df) < 10:  # Not enough data\n        return None\n    \n    personality = {}\n    \n    # Message frequency\n    msg_per_day = len(user_df) / len(user_df['Date'].dt.date.unique())\n    if msg_per_day > 20:\n        personality['chattiness'] = \"Very talkative\"\n    elif msg_per_day > 10:\n        personality['chattiness'] = \"Talkative\"\n    elif msg_per_day > 5:\n        personality['chattiness'] = \"Moderately talkative\"\n    else:\n        personality['chattiness'] = \"Reserved\""
    },
    {
      "index": 28,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "28",
      "text": "ity['chattiness'] = \"Moderately talkative\"\n    else:\n        personality['chattiness'] = \"Reserved\"\n    \n    # Message length\n    avg_length = user_df['message_length'].mean()\n    if avg_length > 100:\n        personality['verbosity'] = \"Very detailed communicator\"\n    elif avg_length > 50:\n        personality['verbosity'] = \"Detailed communicator\"\n    elif avg_length > 20:\n        personality['verbosity'] = \"Concise communicator\"\n    else:\n        personality['verbosity'] = \"Brief communicator\"\n    \n    # Response time (if available)\n    # This is complex and requires determining conversation threads\n    \n    # Time patterns\n    hour_counts = user_df['hour'].value_counts()\n    max_hour = hour_counts.idxmax()\n    if 5 <= max_hour < 12:\n        personality['active_time'] = \"Morning person\""
    },
    {
      "index": 29,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "29",
      "text": "ur_counts.idxmax()\n    if 5 <= max_hour < 12:\n        personality['active_time'] = \"Morning person\"\n    elif 12 <= max_hour < 17:\n        personality['active_time'] = \"Afternoon person\"\n    elif 17 <= max_hour < 21:\n        personality['active_time'] = \"Evening person\"\n    else:\n        personality['active_time'] = \"Night owl\"\n    \n    # Weekday vs Weekend\n    day_type_counts = user_df['day_type'].value_counts()\n    if 'Weekend' in day_type_counts and 'Weekday' in day_type_counts:\n        weekend_ratio = day_type_counts['Weekend'] / (day_type_counts['Weekend'] + day_type_counts['Weekday'])\n        if weekend_ratio > 0.6:\n            personality['day_preference'] = \"Weekend chatter\"\n        elif weekend_ratio < 0.2:\n            personality['day_preference'] = \"Weekday chatter\""
    },
    {
      "index": 30,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "30",
      "text": "er\"\n        elif weekend_ratio < 0.2:\n            personality['day_preference'] = \"Weekday chatter\"\n        else:\n            personality['day_preference'] = \"Consistent throughout the week\"\n    \n    # Sentiment\n    avg_sentiment = user_df['sentiment_score'].mean()\n    if avg_sentiment > 0.2:\n        personality['tone'] = \"Very positive\"\n    elif avg_sentiment > 0.05:\n        personality['tone'] = \"Positive\"\n    elif avg_sentiment > -0.05:\n        personality['tone'] = \"Neutral\"\n    elif avg_sentiment > -0.2:\n        personality['tone'] = \"Negative\"\n    else:\n        personality['tone'] = \"Very negative\"\n    \n    # Emoji usage\n    emoji_count = sum(len([c for c in msg if c in emoji.EMOJI_DATA]) for msg in user_df['Message'])\n    emoji_per_msg = emoji_count / len(user_df)"
    },
    {
      "index": 31,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "31",
      "text": "in emoji.EMOJI_DATA]) for msg in user_df['Message'])\n    emoji_per_msg = emoji_count / len(user_df)\n    if emoji_per_msg > 2:\n        personality['expressiveness'] = \"Very expressive with emojis\"\n    elif emoji_per_msg > 1:\n        personality['expressiveness'] = \"Expressive with emojis\"\n    elif emoji_per_msg > 0.5:\n        personality['expressiveness'] = \"Occasionally uses emojis\"\n    elif emoji_per_msg > 0:\n        personality['expressiveness'] = \"Rarely uses emojis\"\n    else:\n        personality['expressiveness'] = \"Doesn't use emojis\"\n    \n    return personality"
    },
    {
      "index": 32,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "32",
      "text": "else:\n        personality['expressiveness'] = \"Doesn't use emojis\"\n    \n    return personality\n\n\ndef conversation_pattern_analysis(df):\n    \"\"\"Analyze conversation patterns\"\"\"\n    # Messages by time of day\n    time_of_day_counts = df['time_of_day'].value_counts()\n    \n    # Messages by day type (weekend vs weekday)\n    day_type_counts = df['day_type'].value_counts()\n    \n    # Calculate average response time (simplified)\n    df['prev_timestamp'] = df['Date'].shift()\n    df['prev_user'] = df['User'].shift()\n    \n    # Filter for actual responses (different user from previous message)\n    response_df = df[(df['User'] != df['prev_user']) & (~df['prev_user'].isna())]\n    response_df['response_time_min'] = (response_df['Date'] - response_df['prev_timestamp']).dt.total_seconds() / 60"
    },
    {
      "index": 33,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "33",
      "text": "nse_time_min'] = (response_df['Date'] - response_df['prev_timestamp']).dt.total_seconds() / 60\n    \n    # Filter out unreasonable response times (e.g., > 24 hours)\n    response_df = response_df[response_df['response_time_min'] < 24*60]\n    \n    avg_response_time = response_df['response_time_min'].mean() if len(response_df) > 0 else None\n    \n    return time_of_day_counts, day_type_counts, avg_response_time"
    },
    {
      "index": 34,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "34",
      "text": "response_df) > 0 else None\n    \n    return time_of_day_counts, day_type_counts, avg_response_time\n\n\ndef predict_user_activity(df, user=None):\n    \"\"\"Simple prediction model for user activity patterns\"\"\"\n    if user and user != \"Everyone\":\n        df = df[df['User'] == user]\n    \n    if len(df) < 30:  # Not enough data for meaningful predictions\n        return None, None\n    \n    # Group by hour and day to get message frequency\n    hourly_activity = df.groupby(['day', 'hour']).size().reset_index(name='message_count')\n    \n    # Create hour of week feature (0-167)\n    day_map = {\n        'Monday': 0,\n        'Tuesday': 24,\n        'Wednesday': 48,\n        'Thursday': 72,\n        'Friday': 96,\n        'Saturday': 120,\n        'Sunday': 144\n    }"
    },
    {
      "index": 35,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "35",
      "text": "'Thursday': 72,\n        'Friday': 96,\n        'Saturday': 120,\n        'Sunday': 144\n    }\n    \n    hourly_activity['hour_of_week'] = hourly_activity['day'].map(day_map) + hourly_activity['hour']\n    \n    # Find top 5 active hours\n    top_hours = hourly_activity.sort_values('message_count', ascending=False).head(5)\n    \n    # Describe top hours in natural language\n    predictions = []\n    for _, row in top_hours.iterrows():\n        day = row['day']\n        hour = row['hour']\n        count = row['message_count']\n        \n        # Format time\n        if hour < 12:\n            time_str = f\"{hour} AM\"\n        elif hour == 12:\n            time_str = \"12 PM\"\n        else:\n            time_str = f\"{hour-12} PM\"\n        \n        predictions.append(f\"{day} at {time_str} ({count} messages)\")"
    },
    {
      "index": 36,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "36",
      "text": "tr = f\"{hour-12} PM\"\n        \n        predictions.append(f\"{day} at {time_str} ({count} messages)\")\n    \n    # Create a heatmap data for visualization\n    heatmap_data = df.groupby(['day', 'hour']).size().unstack(fill_value=0)\n    \n    # Reorder days\n    day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    heatmap_data = heatmap_data.reindex(day_order)\n    \n    return predictions, heatmap_data"
    },
    {
      "index": 37,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "37",
      "text": "y']\n    heatmap_data = heatmap_data.reindex(day_order)\n    \n    return predictions, heatmap_data\n\n\n\ndef seasonal_analysis(df):\n    \"\"\"\n    Analyze seasonal patterns in chat activity by hour, day, and month.\n    \n    Parameters:\n    df (pandas.DataFrame): Preprocessed chat dataframe\n    \n    Returns:\n    dict: Dictionary containing hourly, daily, and monthly DataFrames\n    \"\"\"\n    import pandas as pd\n    \n    # Create a copy to avoid modifying the original\n    df_copy = df.copy()\n    \n    # Check if dataframe is empty or missing required columns\n    required_columns = ['hour', 'day', 'month_name', 'Message']\n    if df_copy.empty or not all(col in df_copy.columns for col in required_columns):\n        return None\n    \n    # Hourly analysis"
    },
    {
      "index": 38,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "38",
      "text": "col in df_copy.columns for col in required_columns):\n        return None\n    \n    # Hourly analysis\n    hourly_data = df_copy.groupby('hour').count()['Message'].reset_index()\n    hourly_data.columns = ['hour', 'message_count']\n    \n    # Daily analysis - group by day of week\n    if 'day' in df_copy.columns:\n        daily_data = df_copy.groupby('day').count()['Message'].reset_index()\n        daily_data.columns = ['day_name', 'message_count']\n    else:\n        # If day column is missing, create empty dataframe\n        daily_data = pd.DataFrame(columns=['day_name', 'message_count'])\n    \n    # Monthly analysis\n    monthly_data = df_copy.groupby('month_name').count()['Message'].reset_index()\n    monthly_data.columns = ['month_name', 'message_count']"
    },
    {
      "index": 39,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "39",
      "text": "').count()['Message'].reset_index()\n    monthly_data.columns = ['month_name', 'message_count']\n    \n    # Create dictionary with all seasonal data\n    seasonal_data = {\n        'hourly': hourly_data,\n        'daily': daily_data,\n        'monthly': monthly_data\n    }\n    \n    return seasonal_data"
    },
    {
      "index": 40,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "40",
      "text": "'daily': daily_data,\n        'monthly': monthly_data\n    }\n    \n    return seasonal_data\n\n\ndef calculate_message_intensity(df):\n    \"\"\"\n    Calculate message intensity as messages per minute over time.\n    \n    Parameters:\n    df (pandas.DataFrame): Preprocessed chat dataframe\n    \n    Returns:\n    pandas.DataFrame: DataFrame with datetime and intensity columns\n    \"\"\"\n    import pandas as pd\n    from datetime import timedelta\n    \n    # Create a copy to avoid modifying the original\n    df_copy = df.copy()\n    \n    # Check if dataframe is empty or missing Date column\n    if df_copy.empty or 'Date' not in df_copy.columns or 'Time' not in df_copy.columns:\n        return pd.DataFrame()\n    \n    # Make sure we have datetime information\n    try:"
    },
    {
      "index": 41,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "41",
      "text": "y.columns:\n        return pd.DataFrame()\n    \n    # Make sure we have datetime information\n    try:\n        # Create a combined datetime column if it doesn't exist\n        if 'datetime' not in df_copy.columns:\n            # Ensure Date is datetime type\n            if not pd.api.types.is_datetime64_any_dtype(df_copy['Date']):\n                df_copy['Date'] = pd.to_datetime(df_copy['Date'])\n                \n            # Create datetime by combining date and time\n            df_copy['datetime'] = pd.to_datetime(\n                df_copy['Date'].dt.strftime('%Y-%m-%d') + ' ' + \n                df_copy['Time'].astype(str)\n            )\n    except:\n        # If datetime creation fails, return empty dataframe\n        return pd.DataFrame()\n    \n    # Sort by datetime"
    },
    {
      "index": 42,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "42",
      "text": "me creation fails, return empty dataframe\n        return pd.DataFrame()\n    \n    # Sort by datetime\n    df_copy = df_copy.sort_values('datetime')\n    \n    # Calculate message intensity (messages per minute)\n    # Group by minute and count messages\n    df_copy['minute'] = df_copy['datetime'].dt.floor('min')\n    minute_counts = df_copy.groupby('minute').size().reset_index(name='count')\n    minute_counts.columns = ['datetime', 'intensity']\n    \n    return minute_counts"
    },
    {
      "index": 43,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "43",
      "text": "name='count')\n    minute_counts.columns = ['datetime', 'intensity']\n    \n    return minute_counts\n\n\ndef calculate_long_term_trends(df):\n  \n    import pandas as pd\n    \n    # Create a copy to avoid modifying the original\n    df_copy = df.copy()\n    \n    # Check if dataframe is empty or missing Date column\n    if df_copy.empty or 'Date' not in df_copy.columns:\n        return pd.DataFrame()\n    \n    # Make sure Date is datetime type\n    try:\n        if not pd.api.types.is_datetime64_any_dtype(df_copy['Date']):\n            df_copy['Date'] = pd.to_datetime(df_copy['Date'])\n    except:\n        return pd.DataFrame()\n    \n    # Extract just the date portion\n    df_copy['date'] = df_copy['Date'].dt.date\n    \n    # Group by date and count messages"
    },
    {
      "index": 44,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "44",
      "text": "e portion\n    df_copy['date'] = df_copy['Date'].dt.date\n    \n    # Group by date and count messages\n    daily_counts = df_copy.groupby('date').size().reset_index(name='message_count')\n    \n    # Convert date column to datetime for sorting and calculations\n    daily_counts['date'] = pd.to_datetime(daily_counts['date'])\n    \n    # Sort by date\n    daily_counts = daily_counts.sort_values('date')\n    \n    # Calculate rolling averages\n    daily_counts['7d_rolling_avg'] = daily_counts['message_count'].rolling(window=7, min_periods=1).mean()\n    daily_counts['30d_rolling_avg'] = daily_counts['message_count'].rolling(window=30, min_periods=1).mean()\n    \n    return daily_counts"
    },
    {
      "index": 45,
      "filename": "functions.py",
      "filepath": "ChatIQ-main\\functions.py",
      "chunk_index": "45",
      "text": "daily_counts['message_count'].rolling(window=30, min_periods=1).mean()\n    \n    return daily_counts"
    },
    {
      "index": 46,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "0",
      "text": "import streamlit as st\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.font_manager import FontProperties\nimport seaborn as sns\nimport time\nimport functions\nimport ml_models\nimport theme_manager \nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom PIL import Image\nfrom fpdf import FPDF\nimport io\nimport pdf_exporter\n# Set page config\nst.set_page_config(\n    page_title=\"Chat Analyzer\",\n    page_icon=\"üí¨\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\ntheme_manager.apply_theme()\n# Custom CSS\nst.markdown(\"\"\"\n<style>\n    .reportview-container .main .block-container {\n        max-width: 1200px;\n        padding-top: 2rem;\n        padding-bottom: 2rem;\n    }\n    .stProgress > div > div > div > div {"
    },
    {
      "index": 47,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "1",
      "text": "padding-top: 2rem;\n        padding-bottom: 2rem;\n    }\n    .stProgress > div > div > div > div {\n        background-color: #4CAF50;\n    }\n    .stTabs [data-baseweb=\"tab-list\"] {\n        gap: 24px;\n    }\n    .stTabs [data-baseweb=\"tab\"] {\n        height: 50px;\n        white-space: pre-wrap;\n        background-color: #f0f2f6;\n        border-radius: 4px 4px 0px 0px;\n        gap: 1px;\n        padding-top: 10px;\n        padding-bottom: 10px;\n    }\n    .stTabs [aria-selected=\"true\"] {\n        background-color: #e6f3ff;\n        border-bottom-color: #4CAF50;\n    }\n    .stTitle {\n        font-weight: bold;\n        font-size: 24px;\n        color: #333;\n    }\n    .stSubheader {\n        font-size: 20px;\n        font-weight: 600;\n        color: #4CAF50;\n    }\n    .metric-card {"
    },
    {
      "index": 48,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "2",
      "text": "font-size: 20px;\n        font-weight: 600;\n        color: #4CAF50;\n    }\n    .metric-card {\n        background-color: #f8f9fa;\n        border-radius: 10px;\n        padding: 15px;\n        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# Title\nst.title('Chat Analytics Pro')\nst.markdown('#### Analyze your WhatsApp chats with ML features')"
    },
    {
      "index": 49,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "3",
      "text": "le\nst.title('Chat Analytics Pro')\nst.markdown('#### Analyze your WhatsApp chats with ML features')\n\n# Sidebar\nwith st.sidebar:\n    st.image(\"https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/WhatsApp.svg/1200px-WhatsApp.svg.png\", width=100)\n    st.title(\"Settings\")\n    theme_manager.theme_selector()\n    # File uploader\n    file = st.file_uploader(\"Upload WhatsApp Chat (.txt)\", type=['txt'])\n    \n    # Instructions\n    with st.expander(\"How to export WhatsApp chat\"):\n        st.markdown(\"\"\"\n        1. Open WhatsApp chat\n        2. Tap on the three dots in the top right\n        3. Select 'More' > 'Export chat'\n        4. Choose 'Without media'\n        5. Save the .txt file\n        6. Upload the file here\n        \"\"\")"
    },
    {
      "index": 50,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "4",
      "text": "Choose 'Without media'\n        5. Save the .txt file\n        6. Upload the file here\n        \"\"\")\n\n# Main content\nif file:\n    with st.spinner('Processing chat data...'):\n        # Progress bar\n        progress_bar = st.progress(0)\n        \n        # Generate DataFrame\n        df = functions.generateDataFrame(file)\n        progress_bar.progress(20)\n        \n        # Date format selection\n        date_format = st.radio(\"Select Date Format in your chat export:\", ('dd/mm/yyyy', 'mm/dd/yyyy'))\n        dayfirst = True if date_format == 'dd/mm/yyyy' else False\n        \n        # Get users\n        users = functions.getUsers(df)\n        progress_bar.progress(30)\n        \n        # Sidebar user selection\n        with st.sidebar:\n            selected_user = st.selectbox(\"Select User\", users)"
    },
    {
      "index": 51,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "5",
      "text": "r selection\n        with st.sidebar:\n            selected_user = st.selectbox(\"Select User\", users)\n            \n            # Analysis button\n            analyze_button = st.button(\"Analyze Chat\", type=\"primary\")\n        \n        # If analyze button is clicked\n        if analyze_button:\n            # Preprocess data\n            df = functions.PreProcess(df, dayfirst)\n            progress_bar.progress(40)\n            \n            # Filter for selected user\n            if selected_user != \"Everyone\":\n                user_df = df[df['User'] == selected_user]\n                title_name = f\"{selected_user}'s\"\n            else:\n                user_df = df\n                title_name = \"Group\"\n            \n            # Get statistics"
    },
    {
      "index": 52,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "6",
      "text": "user_df = df\n                title_name = \"Group\"\n            \n            # Get statistics\n            filtered_df, media_cnt, deleted_msgs_cnt, links_cnt, word_count, msg_count, avg_msg_length = functions.getStats(user_df)\n            progress_bar.progress(50)\n            \n            # Add sentiment analysis\n            filtered_df, user_sentiment, sentiment_counts, sentiment_over_time = functions.sentiment_analysis(filtered_df)\n            progress_bar.progress(60)\n            \n            # Create tabs\n            tabs = st.tabs([\n                \"üìä Overview\", \n                \"üë• User Analysis\", \n                \"üí¨ Message Analysis\", \n                \"üîç Topic Analysis\",\n                \"üìà Prediction & Trends\",\n                \"üß† ML Insights\"\n            ])"
    },
    {
      "index": 53,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "7",
      "text": "\"üìà Prediction & Trends\",\n                \"üß† ML Insights\"\n            ])\n            \n            # Overview Tab\n            with tabs[0]:\n                st.header(f\"{title_name} Chat Overview\")\n                \n                # hvhjkljhgcfxd\n                st.markdown(\"## üì• Download Chat Analysis Report\")\n\n                # üìÑ CSV Export\n                csv = df.to_csv(index=False).encode('utf-8')\n                st.download_button(\n                    label=\"üìÑ Download CSV\",\n                    data=csv,\n                    file_name='chat_report.csv',\n                    mime='text/csv',\n                    key='csv-download'\n                )"
    },
    {
      "index": 54,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "8",
      "text": "sv',\n                    mime='text/csv',\n                    key='csv-download'\n                )\n\n                # üìä Excel Export\n                excel_buffer = io.BytesIO()\n                with pd.ExcelWriter(excel_buffer, engine='xlsxwriter') as writer:\n                    df.to_excel(writer, sheet_name='Report', index=False)\n                st.download_button(\n                    label=\"üìä Download Excel\",\n                    data=excel_buffer.getvalue(),\n                    file_name='chat_report.xlsx',\n                    mime='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n                    key='excel-download'\n                )"
    },
    {
      "index": 55,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "9",
      "text": "ts-officedocument.spreadsheetml.sheet',\n                    key='excel-download'\n                )\n\n                # PDF Export\n                stats_dict = {\n                    'msg_count': msg_count,\n                    'user_count': len(filtered_df['User'].unique()),\n                    'days': filtered_df['Date'].nunique(),\n                    'media_cnt': media_cnt,\n                    'word_count': word_count,\n                    'links_cnt': links_cnt,\n                    'user_counts': filtered_df['User'].value_counts(),\n                    'sentiment_counts': sentiment_counts if 'sentiment' in filtered_df.columns else None,\n                }"
    },
    {
      "index": 56,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "10",
      "text": "iment_counts': sentiment_counts if 'sentiment' in filtered_df.columns else None,\n                }\n\n                try:\n                    pdf_bytes = pdf_exporter.generate_report_pdf(\n                        filtered_df,\n                        \"WhatsApp Chat Analysis\",\n                        selected_user,\n                        stats_dict\n                    )\n\n                    st.download_button(\n                        label=\"üìÑ Download PDF\",\n                        data=pdf_bytes,\n                        file_name=f\"whatsapp_analysis_{selected_user}.pdf\",\n                        mime=\"application/pdf\",\n                        key=\"pdf-download\"\n                    )\n                except Exception as e:\n                    st.error(f\"Failed to generate PDF: {str(e)}\")"
    },
    {
      "index": 57,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "11",
      "text": "except Exception as e:\n                    st.error(f\"Failed to generate PDF: {str(e)}\")\n\n                # Basic statistics in cards\n                col1, col2, col3, col4 = st.columns(4)\n                \n                with col1:\n                    st.markdown(f\"\"\"\n                    <div class=\"metric-card\">\n                        <h3>Total Messages</h3>\n                        <h2>{msg_count:,}</h2>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                with col2:\n                    st.markdown(f\"\"\"\n                    <div class=\"metric-card\">\n                        <h3>Total Days</h3>\n                        <h2>{filtered_df['Date'].nunique():,}</h2>\n                    </div>"
    },
    {
      "index": 58,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "12",
      "text": "</h3>\n                        <h2>{filtered_df['Date'].nunique():,}</h2>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                with col3:\n                    st.markdown(f\"\"\"\n                    <div class=\"metric-card\">\n                        <h3>Media Shared</h3>\n                        <h2>{media_cnt:,}</h2>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                with col4:\n                    st.markdown(f\"\"\"\n                    <div class=\"metric-card\">\n                        <h3>Words Exchanged</h3>\n                        <h2>{word_count:,}</h2>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)"
    },
    {
      "index": 59,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "13",
      "text": "}</h2>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                # Secondary statistics\n                col1, col2, col3, col4 = st.columns(4)\n                \n                with col1:\n                    st.markdown(f\"\"\"\n                    <div class=\"metric-card\">\n                        <h3>Average Message Length</h3>\n                        <h2>{avg_msg_length:.1f} chars</h2>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                with col2:\n                    st.markdown(f\"\"\"\n                    <div class=\"metric-card\">\n                        <h3>Links Shared</h3>\n                        <h2>{links_cnt:,}</h2>\n                    </div>"
    },
    {
      "index": 60,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "14",
      "text": "<h3>Links Shared</h3>\n                        <h2>{links_cnt:,}</h2>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                with col3:\n                    st.markdown(f\"\"\"\n                    <div class=\"metric-card\">\n                        <h3>Deleted Messages</h3>\n                        <h2>{deleted_msgs_cnt:,}</h2>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                with col4:\n                    st.markdown(f\"\"\"\n                    <div class=\"metric-card\">\n                        <h3>Msgs per Day</h3>\n                        <h2>{msg_count/filtered_df['Date'].nunique():.1f}</h2>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)"
    },
    {
      "index": 61,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "15",
      "text": "e'].nunique():.1f}</h2>\n                    </div>\n                    \"\"\", unsafe_allow_html=True)\n                \n                # Daily Timeline\n                st.subheader(\"Message Trends\")\n                functions.dailytimeline(filtered_df)\n                progress_bar.progress(70)\n                \n                # Activity Heatmap\n                st.subheader(\"Weekly Activity Heatmap\")\n                user_heatmap = functions.activity_heatmap(filtered_df)\n                fig, ax = plt.subplots(figsize=(12, 6))\n                sns.heatmap(user_heatmap, cmap=\"YlGnBu\", linewidths=0.5, ax=ax)\n                ax.set_title(\"Message Activity by Day and Hour\")\n                st.pyplot(fig)\n                \n                # Most Active Days and Months"
    },
    {
      "index": 62,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "16",
      "text": "our\")\n                st.pyplot(fig)\n                \n                # Most Active Days and Months\n                col1, col2 = st.columns(2)\n                \n                with col1:\n                    st.subheader(\"Activity by Day of Week\")\n                    functions.WeekAct(filtered_df)\n                \n                with col2:\n                    st.subheader(\"Activity by Month\")\n                    functions.MonthAct(filtered_df)\n                \n                # Sentiment Analysis Overview\n                st.subheader(\"Message Sentiment Overview\")\n                col1, col2 = st.columns(2)\n                \n                with col1:\n                    # Sentiment Distribution\n                    fig, ax = plt.subplots(figsize=(10, 6))"
    },
    {
      "index": 63,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "17",
      "text": "# Sentiment Distribution\n                    fig, ax = plt.subplots(figsize=(10, 6))\n                    colors = ['#2ecc71', '#3498db', '#e74c3c']\n                    sentiment_counts.plot(kind='bar', ax=ax, color=colors)\n                    ax.set_title(\"Message Sentiment Distribution\")\n                    ax.set_ylabel(\"Number of Messages\")\n                    st.pyplot(fig)\n                \n                with col2:\n                    # Sentiment Over Time\n                    fig, ax = plt.subplots(figsize=(10, 6))\n                    ax.plot(sentiment_over_time['Date'], sentiment_over_time['sentiment_score'], label='Daily Sentiment')"
    },
    {
      "index": 64,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "18",
      "text": ".plot(sentiment_over_time['Date'], sentiment_over_time['sentiment_score'], label='Daily Sentiment')\n                    ax.plot(sentiment_over_time['Date'], sentiment_over_time['Rolling_Avg'], color='red', linewidth=2, label='7-day Average')\n                    ax.set_title(\"Sentiment Trend Over Time\")\n                    ax.set_ylabel(\"Sentiment Score (-1 to +1)\")\n                    ax.axhline(y=0, color='gray', linestyle='--', alpha=0.7)\n                    ax.legend()\n                    plt.xticks(rotation=45)\n                    plt.tight_layout()\n                    st.pyplot(fig)\n                \n                progress_bar.progress(80)\n            \n            # User Analysis Tab\n            with tabs[1]:\n                st.header(\"User Analysis\")"
    },
    {
      "index": 65,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "19",
      "text": "Analysis Tab\n            with tabs[1]:\n                st.header(\"User Analysis\")\n                \n                if selected_user == \"Everyone\":\n                    # User Message Distribution\n                    st.subheader(\"User Message Distribution\")\n                    user_message_counts = filtered_df['User'].value_counts()\n                    \n                    col1, col2 = st.columns(2)\n                    \n                    with col1:\n                        # User Message Count Table\n                        user_message_pct = (user_message_counts / user_message_counts.sum() * 100).round(2)\n                        user_message_df = pd.DataFrame({\n                            'User': user_message_counts.index,"
    },
    {
      "index": 66,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "20",
      "text": "user_message_df = pd.DataFrame({\n                            'User': user_message_counts.index,\n                            'Messages': user_message_counts.values,\n                            'Percentage': user_message_pct.values\n                        })\n                        st.dataframe(user_message_df, use_container_width=True)\n                    \n                    with col2:\n                        # User Message Count Chart\n                        fig, ax = plt.subplots(figsize=(10, 6))\n                        bars = ax.bar(user_message_df['User'], user_message_df['Messages'], \n                                     color=sns.color_palette(\"viridis\", len(user_message_df)))\n                        ax.set_title(\"Messages Sent by User\")"
    },
    {
      "index": 67,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "21",
      "text": "tte(\"viridis\", len(user_message_df)))\n                        ax.set_title(\"Messages Sent by User\")\n                        ax.set_xlabel(\"User\")\n                        ax.set_ylabel(\"Number of Messages\")\n                        plt.xticks(rotation=45, ha='right')\n                        \n                        # Add data labels\n                        for bar in bars:\n                            height = bar.get_height()\n                            ax.text(bar.get_x() + bar.get_width()/2., height + 5,\n                                   f'{height:,}', ha='center', va='bottom')\n                        \n                        plt.tight_layout()\n                        st.pyplot(fig)\n                    \n                    # User Clustering"
    },
    {
      "index": 68,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "22",
      "text": ")\n                        st.pyplot(fig)\n                    \n                    # User Clustering\n                    st.subheader(\"User Clustering Analysis\")\n                    user_stats, cluster_descriptions = functions.user_clustering(filtered_df)\n                    \n                    if user_stats is not None and 'Cluster' in user_stats.columns:\n                        # Show clusters\n                        st.write(\"Users have been grouped into different clusters based on messaging patterns:\")\n                        \n                        for i, desc in enumerate(cluster_descriptions):\n                            st.write(f\"{desc}\")\n                            cluster_users = user_stats[user_stats['Cluster'] == i]['User'].tolist()"
    },
    {
      "index": 69,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "23",
      "text": "cluster_users = user_stats[user_stats['Cluster'] == i]['User'].tolist()\n                            st.write(f\"Users in this cluster: {', '.join(cluster_users)}\")\n                        \n                        # Plot user clusters\n                        st.subheader(\"User Cluster Visualization\")\n                        \n                        # Combine key user stats for visualization\n                        user_cluster_viz = user_stats[['User', 'Message', 'message_length', 'Cluster']].copy()\n                        \n                        # Create a bubble chart\n                        fig, ax = plt.subplots(figsize=(10, 8))\n                        \n                        # Create scatter plot for each cluster"
    },
    {
      "index": 70,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "24",
      "text": "ze=(10, 8))\n                        \n                        # Create scatter plot for each cluster\n                        for cluster in user_cluster_viz['Cluster'].unique():\n                            cluster_data = user_cluster_viz[user_cluster_viz['Cluster'] == cluster]\n                            ax.scatter(\n                                cluster_data['Message'],\n                                cluster_data['message_length'],\n                                s=200,\n                                alpha=0.7,\n                                label=f'Cluster {cluster+1}'\n                            )\n                        \n                        # Add user labels\n                        for i, row in user_cluster_viz.iterrows():\n                            ax.annotate("
    },
    {
      "index": 71,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "25",
      "text": "for i, row in user_cluster_viz.iterrows():\n                            ax.annotate(\n                                row['User'],\n                                (row['Message'], row['message_length']),\n                                fontsize=9,\n                                ha='center',\n                                va='center'\n                            )\n                        \n                        ax.set_title(\"User Clusters by Message Count and Length\")\n                        ax.set_xlabel(\"Number of Messages\")\n                        ax.set_ylabel(\"Average Message Length\")\n                        ax.legend()\n                        ax.grid(True, linestyle='--', alpha=0.7)\n                        st.pyplot(fig)"
    },
    {
      "index": 72,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "26",
      "text": "x.grid(True, linestyle='--', alpha=0.7)\n                        st.pyplot(fig)\n                    \n                    # User Interaction Network\n                    st.subheader(\"User Interaction Network\")\n                    user_interactions = ml_models.user_interaction_network(filtered_df)\n                    \n                    if user_interactions is not None:\n                        # Create a network visualization\n                        st.write(\"This network shows how users interact with each other. Stronger connections indicate more frequent interactions.\")\n                        \n                        # Filter for significant interactions\n                        significant_interactions = user_interactions[user_interactions['interaction_count'] > 10]"
    },
    {
      "index": 73,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "27",
      "text": "significant_interactions = user_interactions[user_interactions['interaction_count'] > 10]\n                        \n                        # Create network figure\n                        try:\n                            import networkx as nx\n                            \n                            # Create graph\n                            G = nx.DiGraph()\n                            \n                            # Add nodes\n                            all_users = set(significant_interactions['prev_user'].unique()) | set(significant_interactions['User'].unique())\n                            for user in all_users:\n                                G.add_node(user)\n                            \n                            # Add edges"
    },
    {
      "index": 74,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "28",
      "text": "G.add_node(user)\n                            \n                            # Add edges\n                            for _, row in significant_interactions.iterrows():\n                                G.add_edge(\n                                    row['prev_user'],\n                                    row['User'],\n                                    weight=row['interaction_count'],\n                                    width=row['interaction_strength']*5\n                                )\n                            \n                            # Draw graph\n                            fig, ax = plt.subplots(figsize=(12, 10))\n                            pos = nx.spring_layout(G, k=0.3, iterations=50)\n                            \n                            # Draw nodes"
    },
    {
      "index": 75,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "29",
      "text": "yout(G, k=0.3, iterations=50)\n                            \n                            # Draw nodes\n                            nx.draw_networkx_nodes(\n                                G, pos,\n                                node_size=500,\n                                node_color='lightblue',\n                                alpha=0.8\n                            )\n                            \n                            # Draw edges\n                            edge_widths = [G[u][v]['width'] for u, v in G.edges()]\n                            nx.draw_networkx_edges(\n                                G, pos,\n                                width=edge_widths,\n                                alpha=0.5,\n                                edge_color='gray',"
    },
    {
      "index": 76,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "30",
      "text": "dths,\n                                alpha=0.5,\n                                edge_color='gray',\n                                arrows=True,\n                                arrowsize=20\n                            )\n                            \n                            # Draw labels\n                            nx.draw_networkx_labels(\n                                G, pos,\n                                font_size=10\n                            )\n                            \n                            plt.axis('off')\n                            st.pyplot(fig)\n                        except ImportError:\n                            st.write(\"Network visualization requires the networkx package.\")\n                    else:"
    },
    {
      "index": 77,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "31",
      "text": "st.write(\"Network visualization requires the networkx package.\")\n                    else:\n                        st.write(\"Not enough interaction data to create a meaningful network visualization.\")\n                \n                # User Engagement Analysis\n                st.subheader(\"User Engagement Analysis\")\n                user_engagement = ml_models.user_engagement_analysis(filtered_df)\n                \n                if user_engagement is not None:\n                    # Select top users by engagement score\n                    top_users = user_engagement.sort_values('engagement_score', ascending=False).head(10)\n                    \n                    # Show engagement metrics"
    },
    {
      "index": 78,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "32",
      "text": "core', ascending=False).head(10)\n                    \n                    # Show engagement metrics\n                    st.write(\"User engagement metrics based on message frequency and participation:\")\n                    \n                    # Create engagement chart\n                    fig, ax = plt.subplots(figsize=(12, 6))\n                    \n                    # Plot engagement score\n                    bars = ax.bar(\n                        top_users['User'], \n                        top_users['engagement_score'],\n                        color=sns.color_palette(\"viridis\", len(top_users))\n                    )\n                    \n                    ax.set_title(\"User Engagement Scores\")\n                    ax.set_xlabel(\"User\")"
    },
    {
      "index": 79,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "33",
      "text": "ax.set_title(\"User Engagement Scores\")\n                    ax.set_xlabel(\"User\")\n                    ax.set_ylabel(\"Engagement Score\")\n                    plt.xticks(rotation=45, ha='right')\n                    \n                    # Add data labels\n                    for bar in bars:\n                        height = bar.get_height()\n                        ax.text(bar.get_x() + bar.get_width()/2., height + 0.05,\n                               f'{height:.2f}', ha='center', va='bottom')\n                    \n                    plt.tight_layout()\n                    st.pyplot(fig)\n                    \n                    # Show engagement metrics table\n                    st.write(\"Detailed engagement metrics:\")"
    },
    {
      "index": 80,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "34",
      "text": "# Show engagement metrics table\n                    st.write(\"Detailed engagement metrics:\")\n                    engagement_metrics = user_engagement[['User', 'message_count', 'days_active', \n                                                         'participation_rate', 'msgs_per_day', 'engagement_score']]\n                    engagement_metrics = engagement_metrics.sort_values('engagement_score', ascending=False)\n                    \n                    # Format the table\n                    engagement_metrics['participation_rate'] = engagement_metrics['participation_rate'].map(lambda x: f\"{x*100:.1f}%\")\n                    engagement_metrics['msgs_per_day'] = engagement_metrics['msgs_per_day'].map(lambda x: f\"{x:.1f}\")"
    },
    {
      "index": 81,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "35",
      "text": "engagement_metrics['msgs_per_day'] = engagement_metrics['msgs_per_day'].map(lambda x: f\"{x:.1f}\")\n                    engagement_metrics['engagement_score'] = engagement_metrics['engagement_score'].map(lambda x: f\"{x:.2f}\")\n                    \n                    st.dataframe(engagement_metrics, use_container_width=True)\n                \n                progress_bar.progress(85)\n            \n            # Message Analysis Tab\n            with tabs[2]:\n                st.header(\"Message Analysis\")\n                \n                # Message Length Distribution\n                st.subheader(\"Message Length Distribution\")\n                \n                col1, col2 = st.columns(2)\n                \n                with col1:\n                    # Histogram of message lengths"
    },
    {
      "index": 82,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "36",
      "text": "s(2)\n                \n                with col1:\n                    # Histogram of message lengths\n                    fig, ax = plt.subplots(figsize=(10, 6))\n                    sns.histplot(filtered_df['message_length'].clip(upper=200), bins=20, kde=True, ax=ax)\n                    ax.set_title(\"Distribution of Message Lengths\")\n                    ax.set_xlabel(\"Message Length (characters)\")\n                    ax.set_ylabel(\"Frequency\")\n                    st.pyplot(fig)\n                \n                with col2:\n                    # Message length stats\n                    st.write(\"Message length statistics:\")\n                    message_length_stats = pd.DataFrame({\n                        'Statistic': ['Average', 'Median', 'Maximum', 'Minimum'],"
    },
    {
      "index": 83,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "37",
      "text": "= pd.DataFrame({\n                        'Statistic': ['Average', 'Median', 'Maximum', 'Minimum'],\n                        'Value': [\n                            f\"{filtered_df['message_length'].mean():.1f} chars\",\n                            f\"{filtered_df['message_length'].median():.1f} chars\",\n                            f\"{filtered_df['message_length'].max():.1f} chars\",\n                            f\"{filtered_df['message_length'].min():.1f} chars\"\n                        ]\n                    })\n                    st.dataframe(message_length_stats, use_container_width=True)\n                    \n                    # Message type distribution\n                    st.write(\"Message type distribution:\")\n                    \n                    media_count = media_cnt"
    },
    {
      "index": 84,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "38",
      "text": "rite(\"Message type distribution:\")\n                    \n                    media_count = media_cnt\n                    deleted_count = deleted_msgs_cnt\n                    links_count = links_cnt\n                    text_count = msg_count - (media_count + deleted_count + links_count)\n                    \n                    message_types = pd.DataFrame({\n                        'Type': ['Text', 'Media', 'Links', 'Deleted'],\n                        'Count': [text_count, media_count, links_count, deleted_count]\n                    })\n                    \n                    fig, ax = plt.subplots(figsize=(10, 6))\n                    colors = ['#3498db', '#2ecc71', '#9b59b6', '#e74c3c']\n                    ax.pie(\n                        message_types['Count'],"
    },
    {
      "index": 85,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "39",
      "text": "'#9b59b6', '#e74c3c']\n                    ax.pie(\n                        message_types['Count'], \n                        labels=message_types['Type'],\n                        autopct='%1.1f%%',\n                        startangle=90,\n                        colors=colors,\n                        explode=[0.05, 0.05, 0.05, 0.05]\n                    )\n                    ax.set_title(\"Message Type Distribution\")\n                    plt.axis('equal')\n                    st.pyplot(fig)\n                \n                # Emoji Analysis\n                st.subheader(\"Emoji Analysis\")\n                emoji_df = functions.getEmoji(filtered_df)\n                \n                col1, col2 = st.columns(2)\n                \n                with col1:\n                    if not emoji_df.empty:"
    },
    {
      "index": 86,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "40",
      "text": "t.columns(2)\n                \n                with col1:\n                    if not emoji_df.empty:\n                        # Show emoji table\n                        st.dataframe(emoji_df, use_container_width=True)\n                    else:\n                        st.write(\"No emojis found in the selected messages.\")\n                \n                with col2:\n                    if not emoji_df.empty:\n                        # Show emoji pie chart\n                        fig, ax = plt.subplots(figsize=(10, 6))\n                        ax.pie(\n                            emoji_df[1].head(10), \n                            labels=emoji_df[0].head(10),\n                            autopct='%1.1f%%',\n                            startangle=90\n                        )"
    },
    {
      "index": 87,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "41",
      "text": "autopct='%1.1f%%',\n                            startangle=90\n                        )\n                        ax.set_title(\"Top 10 Emojis Used\")\n                        plt.axis('equal')\n                        st.pyplot(fig)\n                \n                # Common Words\n                st.subheader(\"Most Common Words\")\n                common_words = functions.MostCommonWords(filtered_df)\n                \n                if common_words is not None:\n                    fig, ax = plt.subplots(figsize=(12, 6))\n                    ax.bar(common_words[0], common_words[1], color=sns.color_palette(\"viridis\", len(common_words[0])))\n                    ax.set_title(\"Most Frequently Used Words\")\n                    ax.set_xlabel(\"Words\")"
    },
    {
      "index": 88,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "42",
      "text": "ax.set_title(\"Most Frequently Used Words\")\n                    ax.set_xlabel(\"Words\")\n                    ax.set_ylabel(\"Frequency\")\n                    plt.xticks(rotation=45, ha='right')\n                    plt.tight_layout()\n                    st.pyplot(fig)\n                \n                # Word Cloud\n                st.subheader(\"Word Cloud\")\n                word_cloud = functions.create_wordcloud(filtered_df)\n                \n                if word_cloud is not None:\n                    fig, ax = plt.subplots(figsize=(12, 8))\n                    ax.imshow(word_cloud)\n                    ax.axis('off')\n                    st.pyplot(fig)\n                \n                progress_bar.progress(90)\n            \n            # Topic Analysis Tab\n            with tabs[3]:"
    },
    {
      "index": 89,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "43",
      "text": "progress_bar.progress(90)\n            \n            # Topic Analysis Tab\n            with tabs[3]:\n                st.header(\"Topic Analysis\")\n                \n                # Topic Classification\n                st.subheader(\"Conversation Topic Classification\")\n                long_messages, topic_keywords = ml_models.conversation_topic_classifier(filtered_df)\n                \n                if long_messages is not None and topic_keywords is not None:\n                    st.write(\"The AI has identified these main topics in your conversations:\")\n                    \n                    # Display topics and keywords\n                    for topic, keywords in topic_keywords.items():\n                        st.write(f\"{topic}:** {', '.join(keywords[:5])}\")"
    },
    {
      "index": 90,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "44",
      "text": "s():\n                        st.write(f\"{topic}:** {', '.join(keywords[:5])}\")\n                    \n                    # Show top messages for each topic\n                    st.subheader(\"Sample Messages by Topic\")\n                    \n                    for topic_id in long_messages['topic'].unique():\n                        topic_messages = long_messages[long_messages['topic'] == topic_id].head(3)\n                        \n                        st.write(f\"*Topic {topic_id+1}*\")\n                        for _, msg in topic_messages.iterrows():\n                            st.write(f\"- {msg['User']}: {msg['Message'][:100]}...\" if len(msg['Message']) > 100 else f\"- {msg['User']}: {msg['Message']}\")\n                else:"
    },
    {
      "index": 91,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "45",
      "text": "}...\" if len(msg['Message']) > 100 else f\"- {msg['User']}: {msg['Message']}\")\n                else:\n                    st.write(\"Not enough data for topic classification. Need more messages with sufficient length.\")\n                \n                # Response Analysis\n                st.subheader(\"Response Pattern Analysis\")\n                user_response_data = ml_models.user_response_analysis(filtered_df)\n                \n                if user_response_data is not None:\n                    # Filter for significant response pairs\n                    significant_responses = user_response_data[user_response_data['response_count'] > 5]\n                    \n                    if not significant_responses.empty:"
    },
    {
      "index": 92,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "46",
      "text": "'response_count'] > 5]\n                    \n                    if not significant_responses.empty:\n                        st.write(\"Analysis of how quickly users respond to each other:\")\n                        \n                        # Format response time\n                        significant_responses['avg_response_time_formatted'] = significant_responses['avg_response_time'].apply(\n                            lambda x: f\"{int(x//60)}h {int(x%60)}m\" if x >= 60 else f\"{int(x)}m\"\n                        )\n                        \n                        # Format response rate\n                        significant_responses['response_rate_pct'] = significant_responses['response_rate'] * 100\n                        \n                        # Select columns to display"
    },
    {
      "index": 93,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "47",
      "text": "'response_rate'] * 100\n                        \n                        # Select columns to display\n                        display_columns = significant_responses[['sender', 'responder', 'response_count', \n                                                           'avg_response_time_formatted', 'response_rate_pct']]\n                        \n                        # Rename columns\n                        display_columns.columns = ['From', 'To', 'Responses', 'Avg. Response Time', 'Response Rate (%)']\n                        \n                        # Format percentage\n                        display_columns['Response Rate (%)'] = display_columns['Response Rate (%)'].apply(lambda x: f\"{x:.1f}%\")\n                        \n                        # Sort by response count"
    },
    {
      "index": 94,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "48",
      "text": "ly(lambda x: f\"{x:.1f}%\")\n                        \n                        # Sort by response count\n                        display_columns = display_columns.sort_values('Responses', ascending=False)\n                        \n                        # Show table\n                        st.dataframe(display_columns, use_container_width=True)\n                        \n                        # Show response time visualization\n                        st.subheader(\"Response Time Visualization\")\n                        \n                        try:\n                            # Create heatmap data\n                            pivot_response_time = significant_responses.pivot(\n                                index='sender', \n                                columns='responder',"
    },
    {
      "index": 95,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "49",
      "text": "index='sender', \n                                columns='responder', \n                                values='avg_response_time'\n                            ).fillna(0)\n                            \n                            fig, ax = plt.subplots(figsize=(10, 8))\n                            sns.heatmap(\n                                pivot_response_time,\n                                annot=True,\n                                fmt=\".0f\",\n                                cmap=\"YlGnBu\",\n                                ax=ax,\n                                cbar_kws={'label': 'Avg. Response Time (minutes)'}\n                            )\n                            ax.set_title(\"Average Response Time Between Users (minutes)\")"
    },
    {
      "index": 96,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "50",
      "text": ")\n                            ax.set_title(\"Average Response Time Between Users (minutes)\")\n                            plt.tight_layout()\n                            st.pyplot(fig)\n                        except:\n                            st.write(\"Cannot create response time heatmap with current data.\")\n                    else:\n                        st.write(\"Not enough response data between users for meaningful analysis.\")\n                else:\n                    st.write(\"Not enough message data for response pattern analysis.\")\n                \n                # Conversation Intensity\n                st.subheader(\"Conversation Intensity Analysis\")\n                peak_times, conversation_summary = ml_models.conversation_intensity_analysis(filtered_df)"
    },
    {
      "index": 97,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "51",
      "text": "peak_times, conversation_summary = ml_models.conversation_intensity_analysis(filtered_df)\n\n                if peak_times is not None and conversation_summary is not None:\n                    col1, col2 = st.columns(2)\n                    \n                    with col1:\n                        st.write(\"Conversation summary:\")\n                        summary_display = pd.DataFrame({\n                            'Metric': [\n                                'Average Messages per Day',\n                                'Busiest Day', \n                                'Messages on Busiest Day',\n                                'Max Consecutive Busy Days',\n                                'Peak Hour Message Rate (msgs/min)'\n                            ],\n                            'Value': ["
    },
    {
      "index": 98,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "52",
      "text": "Hour Message Rate (msgs/min)'\n                            ],\n                            'Value': [\n                                f\"{conversation_summary['avg_daily_messages']:.1f}\",\n                                conversation_summary['busiest_day'].strftime('%d %b %Y'),\n                                f\"{conversation_summary['busiest_day_count']}\",\n                                f\"{conversation_summary['max_consecutive_busy_days']}\",\n                                f\"{conversation_summary['peak_hour_intensity']:.2f}\"\n                            ]\n                        })\n                        st.dataframe(summary_display, use_container_width=True)\n                    \n                    with col2:\n                        st.write(\"Peak conversation times:\")"
    },
    {
      "index": 99,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "53",
      "text": "with col2:\n                        st.write(\"Peak conversation times:\")\n                        if not peak_times.empty:\n                            # Convert Date to datetime if it's not already\n                            peak_times['Date'] = pd.to_datetime(peak_times['Date'])\n                            \n                            # Now it's safe to use .dt accessor\n                            peak_times['date_formatted'] = peak_times['Date'].dt.strftime('%d %b %Y')\n                            peak_display = peak_times[['date_formatted', 'hour', 'message_count', 'intensity']]\n                            peak_display.columns = ['Date', 'Hour', 'Messages', 'Msgs/Min']"
    },
    {
      "index": 100,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "54",
      "text": "sity']]\n                            peak_display.columns = ['Date', 'Hour', 'Messages', 'Msgs/Min']\n                            peak_display['Hour'] = peak_display['Hour'].apply(lambda x: f\"{x}:00 - {x+1}:00\")\n                            st.dataframe(peak_display, use_container_width=True)\n\n                progress_bar.progress(95)"
    },
    {
      "index": 101,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "55",
      "text": "st.dataframe(peak_display, use_container_width=True)\n\n                progress_bar.progress(95)\n\n            # Prediction & Trends Tab\n            with tabs[4]:\n                st.header(\"Prediction & Trends\")\n                \n                # Message Trend Prediction\n                st.subheader(\"Message Frequency Forecast\")\n                \n                try:\n                    fig, components_fig, forecast = ml_models.perform_message_trend_prediction(filtered_df)\n                    \n                    # Show forecast plot\n                    st.pyplot(fig)\n                    \n                    # Show forecast components\n                    st.subheader(\"Forecast Components\")\n                    st.pyplot(components_fig)"
    },
    {
      "index": 102,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "56",
      "text": "subheader(\"Forecast Components\")\n                    st.pyplot(components_fig)\n                    \n                    # Show forecast table\n                    st.subheader(\"Forecast Data\")\n                    forecast_display = forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(30)\n                    forecast_display.columns = ['Date', 'Predicted Messages', 'Lower Bound', 'Upper Bound']\n                    forecast_display['Date'] = pd.to_datetime(forecast_display['Date']).dt.strftime('%d %b %Y')\n                    forecast_display['Predicted Messages'] = forecast_display['Predicted Messages'].round().astype(int)\n                    forecast_display['Lower Bound'] = forecast_display['Lower Bound'].round().astype(int)"
    },
    {
      "index": 103,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "57",
      "text": "forecast_display['Lower Bound'] = forecast_display['Lower Bound'].round().astype(int)\n                    forecast_display['Upper Bound'] = forecast_display['Upper Bound'].round().astype(int)\n                    st.dataframe(forecast_display, use_container_width=True)\n                except Exception as e:\n                    st.write(\"Not enough data for meaningful trend prediction. Need more consistent chat history.\")\n                    st.write(f\"Error: {e}\")\n                \n                # Seasonal Analysis\n                st.subheader(\"Seasonal Chat Patterns\")\n                \n                try:\n                    seasonal_data = functions.seasonal_analysis(filtered_df)\n                    \n                    if seasonal_data is not None:"
    },
    {
      "index": 104,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "58",
      "text": "asonal_analysis(filtered_df)\n                    \n                    if seasonal_data is not None:\n                        col1, col2 = st.columns(2)\n                        \n                        with col1:\n                            # Hour of day seasonality\n                            fig, ax = plt.subplots(figsize=(10, 6))\n                            sns.lineplot(x='hour', y='message_count', data=seasonal_data['hourly'], marker='o', ax=ax)\n                            ax.set_title(\"Activity by Hour of Day\")\n                            ax.set_xlabel(\"Hour\")\n                            ax.set_ylabel(\"Average Messages\")\n                            ax.set_xticks(range(0, 24, 2))\n                            ax.grid(True, linestyle='--', alpha=0.7)"
    },
    {
      "index": 105,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "59",
      "text": "ax.set_xticks(range(0, 24, 2))\n                            ax.grid(True, linestyle='--', alpha=0.7)\n                            st.pyplot(fig)\n                        \n                        with col2:\n                            # Day of week seasonality\n                            fig, ax = plt.subplots(figsize=(10, 6))\n                            day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n                            sns.barplot(x='day_name', y='message_count', data=seasonal_data['daily'], order=day_order, ax=ax)\n                            ax.set_title(\"Activity by Day of Week\")\n                            ax.set_xlabel(\"Day\")\n                            ax.set_ylabel(\"Average Messages\")"
    },
    {
      "index": 106,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "60",
      "text": "ax.set_xlabel(\"Day\")\n                            ax.set_ylabel(\"Average Messages\")\n                            plt.xticks(rotation=45)\n                            plt.tight_layout()\n                            st.pyplot(fig)\n                            \n                        # Monthly seasonality\n                        st.subheader(\"Monthly Chat Pattern\")\n                        month_order = ['January', 'February', 'March', 'April', 'May', 'June', \n                                       'July', 'August', 'September', 'October', 'November', 'December']\n                        \n                        if 'monthly' in seasonal_data and not seasonal_data['monthly'].empty:\n                            fig, ax = plt.subplots(figsize=(12, 6))"
    },
    {
      "index": 107,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "61",
      "text": "seasonal_data['monthly'].empty:\n                            fig, ax = plt.subplots(figsize=(12, 6))\n                            sns.barplot(x='month_name', y='message_count', data=seasonal_data['monthly'], order=month_order, ax=ax)\n                            ax.set_title(\"Activity by Month\")\n                            ax.set_xlabel(\"Month\")\n                            ax.set_ylabel(\"Average Messages\")\n                            plt.xticks(rotation=45)\n                            plt.tight_layout()\n                            st.pyplot(fig)\n                except Exception as e:\n                    st.write(\"Could not perform seasonal analysis with the current data.\")\n                    st.write(f\"Error: {e}\")\n                \n                # Message Intensity Trends"
    },
    {
      "index": 108,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "62",
      "text": "st.write(f\"Error: {e}\")\n                \n                # Message Intensity Trends\n                st.subheader(\"Message Intensity Trends\")\n                \n                try:\n                    intensity_df = functions.calculate_message_intensity(filtered_df)\n                    \n                    if intensity_df is not None and not intensity_df.empty:\n                        fig = px.line(\n                            intensity_df, \n                            x='datetime', \n                            y='intensity',\n                            title='Message Intensity Over Time (Messages per Minute)',\n                            labels={'datetime': 'Date', 'intensity': 'Messages per Minute'}\n                        )"
    },
    {
      "index": 109,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "63",
      "text": "me': 'Date', 'intensity': 'Messages per Minute'}\n                        )\n                        \n                        fig.update_layout(\n                            height=500,\n                            xaxis_title='Date',\n                            yaxis_title='Messages per Minute',\n                        )\n                        \n                        st.plotly_chart(fig, use_container_width=True)\n                        \n                        # Add rolling average\n                        st.subheader(\"Long-term Conversation Trends\")\n                        long_term_df = functions.calculate_long_term_trends(filtered_df)\n                        \n                        if long_term_df is not None and not long_term_df.empty:\n                            fig = go.Figure()"
    },
    {
      "index": 110,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "64",
      "text": "long_term_df is not None and not long_term_df.empty:\n                            fig = go.Figure()\n                            \n                            # Add daily message count\n                            fig.add_trace(go.Scatter(\n                                x=long_term_df['date'],\n                                y=long_term_df['message_count'],\n                                mode='lines',\n                                name='Daily Messages',\n                                line=dict(color='rgba(0, 119, 182, 0.3)')\n                            ))\n                            \n                            # Add 7-day moving average\n                            fig.add_trace(go.Scatter(\n                                x=long_term_df['date'],"
    },
    {
      "index": 111,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "65",
      "text": "fig.add_trace(go.Scatter(\n                                x=long_term_df['date'],\n                                y=long_term_df['7d_rolling_avg'],\n                                mode='lines',\n                                name='7-day Average',\n                                line=dict(color='rgba(0, 119, 182, 1)', width=2)\n                            ))\n                            \n                            # Add 30-day moving average\n                            fig.add_trace(go.Scatter(\n                                x=long_term_df['date'],\n                                y=long_term_df['30d_rolling_avg'],\n                                mode='lines',\n                                name='30-day Average',"
    },
    {
      "index": 112,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "66",
      "text": "mode='lines',\n                                name='30-day Average',\n                                line=dict(color='rgba(182, 0, 0, 1)', width=2)\n                            ))\n                            \n                            fig.update_layout(\n                                title='Long-term Message Trends',\n                                xaxis_title='Date',\n                                yaxis_title='Messages',\n                                height=500,\n                                legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1)\n                            )\n                            \n                            st.plotly_chart(fig, use_container_width=True)\n                except Exception as e:"
    },
    {
      "index": 113,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "67",
      "text": "st.plotly_chart(fig, use_container_width=True)\n                except Exception as e:\n                    st.write(\"Could not calculate message intensity trends with the current data.\")\n                    st.write(f\"Error: {e}\")\n                \n                progress_bar.progress(98)\n            \n            # ML Insights Tab\n            with tabs[5]:\n                st.header(\"ML Insights\")\n\n                # Sentiment Analysis\n                st.subheader(\"Detailed Sentiment Analysis\")\n\n                col1, col2 = st.columns(2)"
    },
    {
      "index": 114,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "68",
      "text": "st.subheader(\"Detailed Sentiment Analysis\")\n\n                col1, col2 = st.columns(2)\n\n                with col1:\n                    # User sentiment comparison\n                    if selected_user == \"Everyone\" and user_sentiment is not None:\n                        try:\n                            # First determine what type of data structure user_sentiment is\n                            if isinstance(user_sentiment, pd.DataFrame):\n                                # It's already a DataFrame\n                                if 'message_count' not in user_sentiment.columns:\n                                    # Calculate message count\n                                    message_counts = filtered_df.groupby('User').size().reset_index(name='message_count')"
    },
    {
      "index": 115,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "69",
      "text": "message_counts = filtered_df.groupby('User').size().reset_index(name='message_count')\n                                    user_sentiment = user_sentiment.merge(message_counts, on='User', how='left')\n                            else:\n                                # It's likely a Series with user sentiment averages\n                                # Convert to DataFrame with proper column names\n                                if hasattr(user_sentiment, 'index') and hasattr(user_sentiment, 'name'):\n                                    user_sentiment_df = pd.DataFrame({\n                                        'User': user_sentiment.index,\n                                        'avg_sentiment': user_sentiment.values\n                                    })"
    },
    {
      "index": 116,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "70",
      "text": "'avg_sentiment': user_sentiment.values\n                                    })\n                                    \n                                    # Calculate message count\n                                    message_counts = filtered_df.groupby('User').size().reset_index(name='message_count')\n                                    user_sentiment = user_sentiment_df.merge(message_counts, on='User', how='left')\n                                else:\n                                    st.write(\"User sentiment data format is not supported.\")\n                                    user_sentiment = None\n                            \n                            # Now continue with the filtering if we have valid data\n                            if user_sentiment is not None:"
    },
    {
      "index": 117,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "71",
      "text": "with the filtering if we have valid data\n                            if user_sentiment is not None:\n                                # Filter for users with enough messages\n                                user_sentiment_filtered = user_sentiment[user_sentiment['message_count'] > 10]\n                                \n                                if not user_sentiment_filtered.empty:\n                                    fig, ax = plt.subplots(figsize=(10, 6))\n                                    \n                                    # Sort by average sentiment\n                                    user_sentiment_filtered = user_sentiment_filtered.sort_values('avg_sentiment')\n                                    \n                                    # Create bar chart"
    },
    {
      "index": 118,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "72",
      "text": "iment')\n                                    \n                                    # Create bar chart\n                                    bars = ax.bar(\n                                        user_sentiment_filtered['User'],\n                                        user_sentiment_filtered['avg_sentiment'],\n                                        color=sns.diverging_palette(220, 20, as_cmap=True)(\n                                            (user_sentiment_filtered['avg_sentiment'] + 1) / 2\n                                        )\n                                    )\n                                    \n                                    # Add horizontal line at 0\n                                    ax.axhline(y=0, color='gray', linestyle='--', alpha=0.7)"
    },
    {
      "index": 119,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "73",
      "text": "e at 0\n                                    ax.axhline(y=0, color='gray', linestyle='--', alpha=0.7)\n                                    \n                                    ax.set_title(\"Average Sentiment by User\")\n                                    ax.set_xlabel(\"User\")\n                                    ax.set_ylabel(\"Average Sentiment (-1 to +1)\")\n                                    plt.xticks(rotation=45, ha='right')\n                                    \n                                    # Add data labels\n                                    for bar in bars:\n                                        height = bar.get_height()\n                                        ax.text(\n                                            bar.get_x() + bar.get_width()/2.,"
    },
    {
      "index": 120,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "74",
      "text": "ax.text(\n                                            bar.get_x() + bar.get_width()/2.,\n                                            height + 0.05 if height >= 0 else height - 0.1,\n                                            f'{height:.2f}',\n                                            ha='center',\n                                            va=('bottom' if height >= 0 else 'top')\n                                        )\n                                    \n                                    plt.tight_layout()\n                                    st.pyplot(fig)\n                                else:\n                                    st.write(\"Not enough data for user sentiment comparison.\")\n                        except Exception as e:"
    },
    {
      "index": 121,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "75",
      "text": "te(\"Not enough data for user sentiment comparison.\")\n                        except Exception as e:\n                            st.write(f\"Error processing user sentiment data: {str(e)}\")\n                    else:\n                        st.write(\"Switch to 'Everyone' view to see user sentiment comparison.\")"
    },
    {
      "index": 122,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "76",
      "text": "e:\n                        st.write(\"Switch to 'Everyone' view to see user sentiment comparison.\")\n\n                with col2:\n                    # Topic-based sentiment\n                    topic_sentiment = ml_models.topic_sentiment_analysis(filtered_df)\n                    \n                    if topic_sentiment is not None and not topic_sentiment.empty:\n                        fig, ax = plt.subplots(figsize=(10, 6))\n                        \n                        # Sort by sentiment\n                        topic_sentiment = topic_sentiment.sort_values('avg_sentiment')\n                        \n                        # Create bar chart\n                        bars = ax.bar(\n                            topic_sentiment['topic'],"
    },
    {
      "index": 123,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "77",
      "text": "chart\n                        bars = ax.bar(\n                            topic_sentiment['topic'],\n                            topic_sentiment['avg_sentiment'],\n                            color=sns.diverging_palette(220, 20, as_cmap=True)(\n                                (topic_sentiment['avg_sentiment'] + 1) / 2\n                            )\n                        )\n                        \n                        # Add horizontal line at 0\n                        ax.axhline(y=0, color='gray', linestyle='--', alpha=0.7)\n                        \n                        ax.set_title(\"Average Sentiment by Topic\")\n                        ax.set_xlabel(\"Topic\")\n                        ax.set_ylabel(\"Average Sentiment (-1 to +1)\")"
    },
    {
      "index": 124,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "78",
      "text": "ic\")\n                        ax.set_ylabel(\"Average Sentiment (-1 to +1)\")\n                        \n                        # Add data labels\n                        for bar in bars:\n                            height = bar.get_height()\n                            ax.text(\n                                bar.get_x() + bar.get_width()/2.,\n                                height + 0.05 if height >= 0 else height - 0.1,\n                                f'{height:.2f}',\n                                ha='center',\n                                va=('bottom' if height >= 0 else 'top')\n                            )\n                        \n                        plt.tight_layout()\n                        st.pyplot(fig)\n                    else:"
    },
    {
      "index": 125,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "79",
      "text": "plt.tight_layout()\n                        st.pyplot(fig)\n                    else:\n                        st.write(\"Not enough data for topic-based sentiment analysis.\")\n                \n                # Conversation Tone Analysis\n        \n                tone_analysis = ml_models.conversation_tone_analysis(filtered_df)"
    },
    {
      "index": 126,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "80",
      "text": "nalysis\n        \n                tone_analysis = ml_models.conversation_tone_analysis(filtered_df)\n\n                if tone_analysis is not None:\n                    # Display tone distribution\n                    st.subheader(\"Conversation Tone Analysis\")\n                    \n                    col1, col2 = st.columns(2)\n                    \n                    with col1:\n                        # Tone distribution pie chart\n                        tone_distribution = tone_analysis['tone_distribution']\n                        \n                        if not tone_distribution.empty:\n                            fig, ax = plt.subplots(figsize=(8, 8))\n                            \n                            # Define colors for each tone"
    },
    {
      "index": 127,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "81",
      "text": "size=(8, 8))\n                            \n                            # Define colors for each tone\n                            colors = {'Positive': '#4CAF50', 'Neutral': '#FFC107', 'Negative': '#F44336'}\n                            tone_colors = [colors[tone] for tone in tone_distribution['tone']]\n                            \n                            # Create pie chart\n                            ax.pie(\n                                tone_distribution['percentage'],\n                                labels=tone_distribution['tone'],\n                                autopct='%1.1f%%',\n                                colors=tone_colors,\n                                startangle=90,\n                                shadow=True\n                            )"
    },
    {
      "index": 128,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "82",
      "text": "shadow=True\n                            )\n                            \n                            ax.set_title(\"Distribution of Conversation Tone\")\n                            ax.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle\n                            \n                            st.pyplot(fig)\n                        else:\n                            st.write(\"Not enough data for tone distribution analysis.\")\n                    \n                    with col2:\n                        # Sentiment over time\n                        daily_sentiment = tone_analysis['daily_sentiment']\n                        \n                        if not daily_sentiment.empty:\n                            fig, ax = plt.subplots(figsize=(10, 6))"
    },
    {
      "index": 129,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "83",
      "text": "if not daily_sentiment.empty:\n                            fig, ax = plt.subplots(figsize=(10, 6))\n                            \n                            # Create line plot\n                            ax.plot(\n                                daily_sentiment['Date'],\n                                daily_sentiment['avg_sentiment'],\n                                marker='o',\n                                linestyle='-',\n                                alpha=0.6,\n                                label='Daily Sentiment'\n                            )\n                            \n                            # Add rolling average\n                            ax.plot(\n                                daily_sentiment['Date'],\n                                daily_sentiment['rolling_sentiment'],"
    },
    {
      "index": 130,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "84",
      "text": "daily_sentiment['Date'],\n                                daily_sentiment['rolling_sentiment'],\n                                color='red',\n                                linewidth=2,\n                                label='7-day Rolling Average'\n                            )\n                            \n                            # Add horizontal line at 0\n                            ax.axhline(y=0, color='gray', linestyle='--', alpha=0.5)\n                            \n                            # Shade the background based on sentiment ranges\n                            ax.axhspan(-1, -0.3, color='#FFCDD2', alpha=0.3)  # Light red for negative\n                            ax.axhspan(-0.3, 0.3, color='#FFFDE7', alpha=0.3)  # Light yellow for neutral"
    },
    {
      "index": 131,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "85",
      "text": "ax.axhspan(-0.3, 0.3, color='#FFFDE7', alpha=0.3)  # Light yellow for neutral\n                            ax.axhspan(0.3, 1, color='#DCEDC8', alpha=0.3)    # Light green for positive\n                            \n                            ax.set_title(\"Sentiment Trend Over Time\")\n                            ax.set_xlabel(\"Date\")\n                            ax.set_ylabel(\"Average Sentiment (-1 to +1)\")\n                            ax.legend()\n                            \n                            # Rotate x-axis labels for better readability\n                            plt.xticks(rotation=45, ha='right')\n                            \n                            plt.tight_layout()\n                            st.pyplot(fig)\n                        else:"
    },
    {
      "index": 132,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "86",
      "text": "plt.tight_layout()\n                            st.pyplot(fig)\n                        else:\n                            st.write(\"Not enough data for sentiment trend analysis.\")\n                    \n                    # Display significant tone shifts\n                    significant_shifts = tone_analysis['significant_shifts']\n                    \n                    if not significant_shifts.empty:\n                        st.subheader(\"Significant Tone Shifts\")\n                        \n                        # Create a dataframe for display\n                        display_shifts = significant_shifts[['Date', 'avg_sentiment', 'sentiment_shift', 'shift_direction']].copy()\n                        display_shifts['Date'] = display_shifts['Date'].astype(str)"
    },
    {
      "index": 133,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "87",
      "text": "ction']].copy()\n                        display_shifts['Date'] = display_shifts['Date'].astype(str)\n                        display_shifts['avg_sentiment'] = display_shifts['avg_sentiment'].round(2)\n                        display_shifts['sentiment_shift'] = display_shifts['sentiment_shift'].round(2)\n                        \n                        # Rename columns for display\n                        display_shifts.columns = ['Date', 'Sentiment', 'Shift Magnitude', 'Direction']\n                        \n                        # Display the table\n                        st.dataframe(display_shifts)\n                    else:\n                        st.write(\"No significant tone shifts detected.\")\n                else:"
    },
    {
      "index": 134,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "88",
      "text": "lse:\n                        st.write(\"No significant tone shifts detected.\")\n                else:\n                    st.write(\"Not enough data for conversation tone analysis.\")"
    },
    {
      "index": 135,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "89",
      "text": "else:\n                    st.write(\"Not enough data for conversation tone analysis.\")\n\n                # \n                # User Style Analysis\n                st.subheader(\"User Communication Style Analysis\")\n                user_styles = ml_models.user_communication_style(filtered_df)\n                \n                if user_styles is not None and not user_styles.empty:\n                    # Select users with enough data\n                    filtered_styles = user_styles[user_styles['message_count'] > 20]\n                    \n                    if not filtered_styles.empty:\n                        # Create radar chart\n                        fig = go.Figure()"
    },
    {
      "index": 136,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "90",
      "text": "# Create radar chart\n                        fig = go.Figure()\n                        \n                        style_metrics = ['formality', 'expressiveness', 'complexity', 'politeness', 'directness']\n                        \n                        for _, user_row in filtered_styles.iterrows():\n                            fig.add_trace(go.Scatterpolar(\n                                r=[user_row[m] for m in style_metrics],\n                                theta=style_metrics,\n                                fill='toself',\n                                name=user_row['User']\n                            ))\n                        \n                        fig.update_layout(\n                            polar=dict(\n                                radialaxis=dict("
    },
    {
      "index": 137,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "91",
      "text": "te_layout(\n                            polar=dict(\n                                radialaxis=dict(\n                                    visible=True,\n                                    range=[0, 1]\n                                )\n                            ),\n                            title=\"User Communication Style Profiles\",\n                            showlegend=True,\n                            height=600\n                        )\n                        \n                        st.plotly_chart(fig, use_container_width=True)\n                        \n                        # Show style description\n                        st.write(\"Communication style metrics explained:\")\n                        style_descriptions = {"
    },
    {
      "index": 138,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "92",
      "text": "st.write(\"Communication style metrics explained:\")\n                        style_descriptions = {\n                            'formality': 'How formal the language used is (higher = more formal)',\n                            'expressiveness': 'Use of emojis, exclamations, and emotional language',\n                            'complexity': 'Complexity of language, sentence structure, and vocabulary',\n                            'politeness': 'Use of polite phrases, requests, and courteous language',\n                            'directness': 'How direct and to-the-point the communication is'\n                        }\n                        \n                        for style, desc in style_descriptions.items():\n                            st.write(f\"- {style.capitalize()}: {desc}\")"
    },
    {
      "index": 139,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "93",
      "text": "style_descriptions.items():\n                            st.write(f\"- {style.capitalize()}: {desc}\")\n                    else:\n                        st.write(\"Not enough messages from each user for meaningful style analysis.\")\n                else:\n                    st.write(\"Could not perform user style analysis with current data.\")\n                \n                # Key Phrase Extraction\n                st.subheader(\"Key Phrases and Topics\")\n                key_phrases = ml_models.extract_key_phrases(filtered_df)\n                \n                if key_phrases is not None and key_phrases:\n                    # Create word cloud for key phrases\n                    from wordcloud import WordCloud"
    },
    {
      "index": 140,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "94",
      "text": "word cloud for key phrases\n                    from wordcloud import WordCloud\n                    \n                    # Create word cloud from phrases with their weights\n                    phrase_weights = {' '.join(phrase): weight for phrase, weight in key_phrases.items()}\n                    \n                    wordcloud = WordCloud(\n                        width=800, \n                        height=400, \n                        background_color='white',\n                        colormap='viridis',\n                        max_words=100\n                    ).generate_from_frequencies(phrase_weights)\n                    \n                    fig, ax = plt.subplots(figsize=(12, 8))\n                    ax.imshow(wordcloud, interpolation='bilinear')\n                    ax.axis('off')"
    },
    {
      "index": 141,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "95",
      "text": "ax.imshow(wordcloud, interpolation='bilinear')\n                    ax.axis('off')\n                    ax.set_title(\"Key Topics and Phrases\")\n                    st.pyplot(fig)\n                    \n                    # Display top phrases in table format\n                    top_phrases = sorted(key_phrases.items(), key=lambda x: x[1], reverse=True)[:20]\n                    phrase_df = pd.DataFrame(top_phrases, columns=['Phrase', 'Relevance Score'])\n                    phrase_df['Phrase'] = phrase_df['Phrase'].apply(lambda x: ' '.join(x))\n                    phrase_df['Relevance Score'] = phrase_df['Relevance Score'].round(3)\n                    \n                    st.write(\"Top key phrases from conversations:\")"
    },
    {
      "index": 142,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "96",
      "text": "].round(3)\n                    \n                    st.write(\"Top key phrases from conversations:\")\n                    st.dataframe(phrase_df, use_container_width=True)\n                else:\n                    st.write(\"Not enough data for key phrase extraction.\")\n                \n                progress_bar.progress(100)\n            \n            # After analysis is done\n            st.success(\"Analysis complete! Explore the tabs to see insights about your WhatsApp chat.\")\n        else:\n            st.info(\"Click the 'Analyze Chat' button to start the analysis.\")"
    },
    {
      "index": 143,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "97",
      "text": "else:\n            st.info(\"Click the 'Analyze Chat' button to start the analysis.\")\n\n        \n\nelse:\n    # Show welcome message and instructions\n    st.markdown(\"\"\"\n    ### üëã Welcome to Chat Analytics Pro!\n    \n    Upload your WhatsApp chat export to get started. This tool provides advanced analytics including:\n    \n    - üìä Message statistics and trends\n    - üë• User behavior analysis\n    - üí¨ Message content analysis\n    - üîç Topic detection and classification\n    - üìà Prediction and trend forecasting\n    - üß† AI-powered insights\n    \n    To get started, export your chat from WhatsApp and upload the .txt file using the sidebar.\n    \"\"\")\n    \n    # Show demo images\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        # st.image(\"whatsapp.png\","
    },
    {
      "index": 144,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "98",
      "text": "demo images\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        # st.image(\"whatsapp.png\", \n        #         caption=\"Advanced Analytics Dashboard\", use_container_width=True)\n        image = Image.open(\"whatsapp.png\")\n        resized_image = image.resize((600, 400))  # Set width and height as needed\n        \n        st.image(resized_image, caption=\"Advanced Analytics Dashboard\", use_container_width=False)\n    \n    with col2:\n        st.image(\"https://images.unsplash.com/photo-1551288049-bebda4e38f71\", \n                caption=\"User Interaction Analysis\", use_container_width=True)\n    \n    # Testimonials\n    st.markdown(\"\"\"\n    ### What users are saying:\n    \n    > \"This tool helped me understand group chat dynamics I never noticed before!\" - Sarah K."
    },
    {
      "index": 145,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "99",
      "text": "> \"This tool helped me understand group chat dynamics I never noticed before!\" - Sarah K.\n    \n    > \"The sentiment analysis feature is surprisingly accurate. Great for tracking team morale.\" - Mark T.\n    \n    > \"I love the topic classification - finally understood what my family chat is really about!\" - Priya M.\n    \"\"\")\n    \n    # FAQ\n    with st.expander(\"Frequently Asked Questions\"):\n        st.markdown(\"\"\"\n        Is my data safe?\n        Yes! Your chat data is processed entirely in your browser session and is not stored on any server.\n        \n        What chat size is recommended?\n        The tool works best with chats containing at least 500 messages. For optimal ML analysis, 1000+ messages are recommended.\n        \n        Can I analyze group chats?"
    },
    {
      "index": 146,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "100",
      "text": "or optimal ML analysis, 1000+ messages are recommended.\n        \n        Can I analyze group chats?\n        Yes, both individual and group chats are supported.\n        \n        Will my media files be analyzed?\n        No, only the text content of your chat is analyzed. Export your chat 'Without Media' for faster processing.\n        \n        Which languages are supported?\n        The tool supports chats in any language, though some advanced features work best with English content.\n        \"\"\")\n    \n    # Footer\n    st.markdown(\"\"\"\n    ---\n    Made with ‚ù§ by WhatsApp Chat Analytics Team | [Privacy Policy](https://example.com) | [Terms of Service](https://example.com)\n    \"\"\")"
    },
    {
      "index": 147,
      "filename": "main.py",
      "filepath": "ChatIQ-main\\main.py",
      "chunk_index": "101",
      "text": "tics Team | [Privacy Policy](https://example.com) | [Terms of Service](https://example.com)\n    \"\"\")"
    },
    {
      "index": 148,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "0",
      "text": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.cluster import KMeans\nfrom sklearn.decomposition import PCA\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics import silhouette_score\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.model_selection import train_test_split\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom prophet import Prophet\nimport streamlit as st"
    },
    {
      "index": 149,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "1",
      "text": "express as px\nimport plotly.graph_objects as go\nfrom prophet import Prophet\nimport streamlit as st\n\ndef perform_message_trend_prediction(df, prediction_days=30):\n    \"\"\"Predict future message trends using Facebook Prophet\"\"\"\n  \n    message_counts = df.groupby(pd.Grouper(key='Date', freq='D')).size().reset_index(name='messages')\n\n    message_counts.columns = ['ds', 'y']\n\n    m = Prophet(\n        yearly_seasonality=True,\n        weekly_seasonality=True,\n        daily_seasonality=False,\n        changepoint_prior_scale=0.05\n    )\n    \n    m.fit(message_counts)\n    \n    future = m.make_future_dataframe(periods=prediction_days)\n\n    forecast = m.predict(future)\n\n    fig = m.plot(forecast)\n    plt.title('Message Frequency Forecast')\n    plt.xlabel('Date')\n    plt.ylabel('Number of Messages')"
    },
    {
      "index": 150,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "2",
      "text": "lt.title('Message Frequency Forecast')\n    plt.xlabel('Date')\n    plt.ylabel('Number of Messages')\n\n    plt.plot([], [], 'b-', label='Actual')\n    plt.plot([], [], 'r-', label='Predicted')\n    plt.fill_between([], [], [], color='#0072B2', alpha=0.2, label='Confidence Interval')\n    plt.legend()\n    \n    components_fig = m.plot_components(forecast)\n    \n    return fig, components_fig, forecast\n\ndef user_engagement_analysis(df):\n    \"\"\"Analyze user engagement patterns\"\"\""
    },
    {
      "index": 151,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "3",
      "text": "onents_fig, forecast\n\ndef user_engagement_analysis(df):\n    \"\"\"Analyze user engagement patterns\"\"\"\n\n    user_engagement = df.groupby('User').agg({\n        'Message': 'count',\n        'message_length': ['mean', 'max', 'min', 'std'],\n        'Date': pd.Series.nunique  \n    }).reset_index()\n    \n    user_engagement.columns = ['_'.join(col).strip('_') for col in user_engagement.columns.values]\n    \n    user_engagement = user_engagement.rename(columns={\n        'User_': 'User',\n        'Message_count': 'message_count',\n        'message_length_mean': 'avg_message_length',\n        'message_length_max': 'max_message_length',\n        'message_length_min': 'min_message_length',\n        'message_length_std': 'std_message_length',\n        'Date_nunique': 'days_active'\n    })"
    },
    {
      "index": 152,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "4",
      "text": "'message_length_std': 'std_message_length',\n        'Date_nunique': 'days_active'\n    })\n \n    user_engagement['msgs_per_day'] = user_engagement['message_count'] / user_engagement['days_active']\n    \n    total_days = (df['Date'].max() - df['Date'].min()).days + 1\n \n    user_engagement['participation_rate'] = user_engagement['days_active'] / total_days\n\n    metrics = ['message_count', 'avg_message_length', 'msgs_per_day']\n    for metric in metrics:\n        user_engagement[f'{metric}_zscore'] = (user_engagement[metric] - user_engagement[metric].mean()) / user_engagement[metric].std()\n    \n    user_engagement['engagement_score'] = (\n        (user_engagement['message_count_zscore'] + \n         user_engagement['participation_rate'] * 2) / 3\n    )\n    \n    return user_engagement"
    },
    {
      "index": 153,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "5",
      "text": "+ \n         user_engagement['participation_rate'] * 2) / 3\n    )\n    \n    return user_engagement\n\n\ndef conversation_topic_classifier(df, n_topics=5):\n    \"\"\"Classify conversations into topics using TF-IDF and clustering\"\"\""
    },
    {
      "index": 154,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "6",
      "text": "assifier(df, n_topics=5):\n    \"\"\"Classify conversations into topics using TF-IDF and clustering\"\"\"\n\n    long_messages = df[df['Message'].str.len() > 10]\n    \n    if len(long_messages) < 10:  # Not enough data\n        return None, None\n    \n    # Convert messages to TF-IDF features\n    vectorizer = TfidfVectorizer(\n        max_features=1000,\n        stop_words='english',\n        min_df=2,\n        max_df=0.9\n    )\n    \n    try:\n        # Create document-term matrix\n        X = vectorizer.fit_transform(long_messages['Message'])\n        \n        # Apply dimensionality reduction (PCA)\n        pca = PCA(n_components=min(10, X.shape[0]-1))\n        X_pca = pca.fit_transform(X.toarray())\n        \n        # Determine optimal number of clusters"
    },
    {
      "index": 155,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "7",
      "text": "X_pca = pca.fit_transform(X.toarray())\n        \n        # Determine optimal number of clusters\n        n_clusters_range = range(2, min(n_topics+1, X_pca.shape[0]))\n        \n        if len(n_clusters_range) < 2:  # Not enough data for multiple clusters\n            return None, None\n            \n        silhouette_scores = []\n        \n        for n_clusters in n_clusters_range:\n            kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)\n            cluster_labels = kmeans.fit_predict(X_pca)\n            \n            # Calculate silhouette score\n            silhouette_avg = silhouette_score(X_pca, cluster_labels)\n            silhouette_scores.append(silhouette_avg)\n        \n        # Find optimal number of clusters"
    },
    {
      "index": 156,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "8",
      "text": "silhouette_scores.append(silhouette_avg)\n        \n        # Find optimal number of clusters\n        optimal_n_clusters = n_clusters_range[np.argmax(silhouette_scores)]\n        \n        # Final clustering\n        kmeans = KMeans(n_clusters=optimal_n_clusters, random_state=42, n_init=10)\n        long_messages['topic'] = kmeans.fit_predict(X_pca)\n        \n        # Get top words for each topic\n        topic_keywords = {}\n        order_centroids = kmeans.cluster_centers_.argsort()[:, ::-1]\n        terms = vectorizer.get_feature_names_out()\n        \n        for i in range(optimal_n_clusters):\n            topic_terms = [terms[ind] for ind in order_centroids[i, :10]]\n            topic_keywords[f\"Topic {i+1}\"] = topic_terms\n        \n        return long_messages, topic_keywords"
    },
    {
      "index": 157,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "9",
      "text": "c_keywords[f\"Topic {i+1}\"] = topic_terms\n        \n        return long_messages, topic_keywords\n    \n    except Exception as e:\n        print(f\"Error in topic classification: {e}\")\n        return None, None"
    },
    {
      "index": 158,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "10",
      "text": "ept Exception as e:\n        print(f\"Error in topic classification: {e}\")\n        return None, None\n\ndef user_response_analysis(df):\n    \"\"\"Analyze response patterns between users\"\"\"\n    if len(df) < 30:  # Not enough data\n        return None\n    \n    # Sort by date and time\n    df = df.sort_values(by=['Date', 'Time'])\n    \n    # Add previous message user and time\n    df['prev_user'] = df['User'].shift(1)\n    df['prev_time'] = df['Date'].shift(1)\n    \n    # Calculate response time in minutes\n    df['response_time'] = (df['Date'] - df['prev_time']).dt.total_seconds() / 60\n    \n    # Filter for actual responses (different user from previous)\n    responses = df[(df['User'] != df['prev_user']) & (df['response_time'] < 60*24)]  # Limit to 24 hours"
    },
    {
      "index": 159,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "11",
      "text": "ses = df[(df['User'] != df['prev_user']) & (df['response_time'] < 60*24)]  # Limit to 24 hours\n    \n    if len(responses) < 10:  # Not enough response data\n        return None\n    \n    # Group by user pairs with explicit column names to avoid multi-level issues\n    message_counts = responses.groupby(['prev_user', 'User']).size().reset_index(name='response_count')\n    \n    # Calculate response time metrics separately\n    response_times = responses.groupby(['prev_user', 'User'])['response_time'].agg([\n        ('avg_response_time', 'mean'),\n        ('median_response_time', 'median'),\n        ('min_response_time', 'min'),\n        ('max_response_time', 'max')\n    ]).reset_index()\n    \n    # Merge the response counts and response times"
    },
    {
      "index": 160,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "12",
      "text": "response_time', 'max')\n    ]).reset_index()\n    \n    # Merge the response counts and response times\n    user_pairs = message_counts.merge(response_times, on=['prev_user', 'User'])\n    \n    # Rename columns for clarity\n    user_pairs = user_pairs.rename(columns={\n        'prev_user': 'sender',\n        'User': 'responder'\n    })\n    \n    # Calculate response rates\n    total_messages_by_user = df.groupby('User').size().reset_index(name='total_messages')\n    \n    # Merge with user_pairs\n    user_pairs = user_pairs.merge(\n        total_messages_by_user.rename(columns={'User': 'sender', 'total_messages': 'sender_messages'}),\n        on='sender',\n        how='left'\n    )\n    \n    # Calculate response rate"
    },
    {
      "index": 161,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "13",
      "text": "ender_messages'}),\n        on='sender',\n        how='left'\n    )\n    \n    # Calculate response rate\n    user_pairs['response_rate'] = user_pairs['response_count'] / user_pairs['sender_messages']\n    \n    return user_pairs"
    },
    {
      "index": 162,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "14",
      "text": "e_rate'] = user_pairs['response_count'] / user_pairs['sender_messages']\n    \n    return user_pairs\n\ndef conversation_intensity_analysis(df):\n    \"\"\"Analyze conversation intensity patterns\"\"\"\n    # Create hourly message counts\n    hourly_counts = df.groupby([df['Date'].dt.date, df['hour']]).size().reset_index(name='message_count')\n    \n    # Identify active conversation hours (more than 10 messages)\n    active_hours = hourly_counts[hourly_counts['message_count'] > 10]\n    \n    if len(active_hours) < 5:  # Not enough data\n        return None, None\n    \n    # Calculate conversation intensity (messages per minute)\n    active_hours['intensity'] = active_hours['message_count'] / 60\n    \n    # Find peak conversation times"
    },
    {
      "index": 163,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "15",
      "text": "ive_hours['intensity'] = active_hours['message_count'] / 60\n    \n    # Find peak conversation times\n    peak_times = active_hours.sort_values('message_count', ascending=False).head(5)\n    \n    # Calculate average daily message count\n    daily_counts = df.groupby(df['Date'].dt.date).size()\n    avg_daily_messages = daily_counts.mean()\n    busiest_day = daily_counts.idxmax()\n    busiest_day_count = daily_counts.max()\n    \n    # Calculate consecutive busy days (days with more than average messages)\n    busy_days = daily_counts[daily_counts > avg_daily_messages].index\n    if len(busy_days) > 1:\n        busy_days = pd.Series(busy_days).sort_values()\n        busy_days_diff = busy_days.diff().dt.days\n        max_consecutive = 1\n        current_consecutive = 1"
    },
    {
      "index": 164,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "16",
      "text": "iff = busy_days.diff().dt.days\n        max_consecutive = 1\n        current_consecutive = 1\n        \n        for diff in busy_days_diff:\n            if diff == 1:\n                current_consecutive += 1\n                max_consecutive = max(max_consecutive, current_consecutive)\n            else:\n                current_consecutive = 1\n    else:\n        max_consecutive = len(busy_days)\n    \n    # Create summary stats\n    summary = {\n        'avg_daily_messages': avg_daily_messages,\n        'busiest_day': busiest_day,\n        'busiest_day_count': busiest_day_count,\n        'max_consecutive_busy_days': max_consecutive,\n        'peak_hour_intensity': peak_times['intensity'].max() if not peak_times.empty else 0\n    }\n    \n    return peak_times, summary"
    },
    {
      "index": 165,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "17",
      "text": "_times['intensity'].max() if not peak_times.empty else 0\n    }\n    \n    return peak_times, summary\n\ndef communication_pattern_prediction(df, selected_user=None):\n    \"\"\"Predict communication patterns for a specific user or everyone\"\"\"\n    if selected_user and selected_user != \"Everyone\":\n        user_df = df[df['User'] == selected_user]\n    else:\n        user_df = df\n    \n    if len(user_df) < 50:  # Not enough data\n        return None, None\n    \n    # Aggregate data by day\n    daily_messages = user_df.groupby(user_df['Date'].dt.date).size().reset_index(name='message_count')\n    daily_messages['day_of_week'] = pd.to_datetime(daily_messages['Date']).dt.dayofweek\n    \n    # Calculate rolling averages"
    },
    {
      "index": 166,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "18",
      "text": "_week'] = pd.to_datetime(daily_messages['Date']).dt.dayofweek\n    \n    # Calculate rolling averages\n    daily_messages['rolling_avg'] = daily_messages['message_count'].rolling(window=7, min_periods=1).mean()\n    \n    # Prepare features\n    X = pd.get_dummies(daily_messages['day_of_week'], prefix='day')\n    X['week_num'] = (pd.to_datetime(daily_messages['Date']) - pd.to_datetime(daily_messages['Date']).min()).dt.days // 7\n    \n    # Target variable\n    y = daily_messages['message_count']\n    \n    # Split data\n    try:\n        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n        \n        # Train model\n        model = RandomForestRegressor(n_estimators=100, random_state=42)\n        model.fit(X_train, y_train)\n        \n        # Make predictions"
    },
    {
      "index": 167,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "19",
      "text": "ators=100, random_state=42)\n        model.fit(X_train, y_train)\n        \n        # Make predictions\n        y_pred = model.fit(X_train, y_train).predict(X_test)\n        \n        # Calculate feature importance\n        feature_importance = pd.DataFrame({\n            'feature': X.columns,\n            'importance': model.feature_importances_\n        }).sort_values('importance', ascending=False)\n        \n        # Create prediction for next week\n        last_date = pd.to_datetime(daily_messages['Date']).max()\n        next_week_dates = [last_date + pd.Timedelta(days=i) for i in range(1, 8)]\n        \n        next_week_df = pd.DataFrame({\n            'Date': next_week_dates,\n            'day_of_week': [date.dayofweek for date in next_week_dates]\n        })"
    },
    {
      "index": 168,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "20",
      "text": "_dates,\n            'day_of_week': [date.dayofweek for date in next_week_dates]\n        })\n        \n        next_week_X = pd.get_dummies(next_week_df['day_of_week'], prefix='day')\n        \n        # Handle missing columns\n        for col in X.columns:\n            if col not in next_week_X.columns and col != 'week_num':\n                next_week_X[col] = 0\n        \n        next_week_X['week_num'] = (X['week_num'].max() + 1)\n        \n        # Make sure columns are in the same order\n        next_week_X = next_week_X[X.columns]\n        \n        # Predict\n        next_week_pred = model.predict(next_week_X)\n        \n        # Combine with dates\n        next_week_df['predicted_messages'] = next_week_pred\n        \n        return next_week_df, feature_importance\n    \n    except Exception as e:"
    },
    {
      "index": 169,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "21",
      "text": "_week_pred\n        \n        return next_week_df, feature_importance\n    \n    except Exception as e:\n        print(f\"Error in communication pattern prediction: {e}\")\n        return None, None"
    },
    {
      "index": 170,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "22",
      "text": "n as e:\n        print(f\"Error in communication pattern prediction: {e}\")\n        return None, None\n\ndef user_interaction_network(df):\n    \"\"\"Create a user interaction network analysis\"\"\"\n    if len(df) < 50:  # Not enough data\n        return None\n    \n    # Sort by date and time\n    df = df.sort_values(by=['Date', 'Time'])\n    \n    # Add previous message user\n    df['prev_user'] = df['User'].shift(1)\n    \n    # Filter for actual interactions (different user from previous)\n    interactions = df[df['User'] != df['prev_user']].copy()\n    \n    if len(interactions) < 10:  # Not enough interaction data\n        return None\n    \n    # Count interactions between users\n    user_interactions = interactions.groupby(['prev_user', 'User']).size().reset_index(name='interaction_count')"
    },
    {
      "index": 171,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "23",
      "text": "ons = interactions.groupby(['prev_user', 'User']).size().reset_index(name='interaction_count')\n    \n    # Remove self-interactions and None values\n    user_interactions = user_interactions[\n        (user_interactions['prev_user'] != user_interactions['User']) & \n        (~user_interactions['prev_user'].isna()) &\n        (~user_interactions['User'].isna())\n    ]\n    \n    # Calculate normalized interaction strength\n    max_interactions = user_interactions['interaction_count'].max()\n    user_interactions['interaction_strength'] = user_interactions['interaction_count'] / max_interactions\n    \n    # Calculate total interactions for each user\n    user_total_interactions = pd.concat([\n        user_interactions.groupby('User')['interaction_count'].sum().reset_index(name='total_interactions'),"
    },
    {
      "index": 172,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "24",
      "text": "ser_interactions.groupby('User')['interaction_count'].sum().reset_index(name='total_interactions'),\n        user_interactions.groupby('prev_user')['interaction_count'].sum().reset_index().rename(columns={'prev_user': 'User', 'interaction_count': 'initiated_interactions'})\n    ], axis=0).groupby('User').sum().reset_index()\n    \n    # Merge with user_interactions\n    user_interactions = user_interactions.merge(\n        user_total_interactions,\n        left_on='User',\n        right_on='User',\n        how='left'\n    )\n    \n    user_interactions = user_interactions.merge(\n        user_total_interactions,\n        left_on='prev_user',\n        right_on='User',\n        how='left',\n        suffixes=('', '_initiator')\n    ).rename(columns={'User_initiator': 'init_user'})"
    },
    {
      "index": 173,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "25",
      "text": "ft',\n        suffixes=('', '_initiator')\n    ).rename(columns={'User_initiator': 'init_user'})\n    \n    # Calculate interaction percentage\n    user_interactions['interaction_percentage'] = user_interactions['interaction_count'] / user_interactions['total_interactions'] * 100\n    \n    return user_interactions"
    },
    {
      "index": 174,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "26",
      "text": "eraction_count'] / user_interactions['total_interactions'] * 100\n    \n    return user_interactions\n\ndef generate_chat_analytics_report(df, selected_user=None):\n    \"\"\"Generate comprehensive chat analytics report\"\"\"\n    if selected_user and selected_user != \"Everyone\":\n        user_df = df[df['User'] == selected_user]\n        title = f\"Chat Analytics Report for {selected_user}\"\n    else:\n        user_df = df\n        title = \"Chat Analytics Report for All Users\"\n    \n    # Basic statistics\n    total_messages = len(user_df)\n    total_days = (user_df['Date'].max() - user_df['Date'].min()).days + 1\n    avg_messages_per_day = round(total_messages / total_days, 2)\n    \n    # Message length statistics\n    avg_message_length = round(user_df['message_length'].mean(), 2)\n    \n    # Time statistics"
    },
    {
      "index": 175,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "27",
      "text": "tics\n    avg_message_length = round(user_df['message_length'].mean(), 2)\n    \n    # Time statistics\n    active_hours = user_df.groupby('hour').size().reset_index(name='message_count')\n    peak_hour = active_hours.loc[active_hours['message_count'].idxmax(), 'hour']\n    \n    # Day statistics\n    active_days = user_df.groupby('day').size().reset_index(name='message_count')\n    peak_day = active_days.loc[active_days['message_count'].idxmax(), 'day']\n    \n    # Sentiment statistics\n    avg_sentiment = round(user_df['sentiment_score'].mean(), 2)\n    sentiment_distribution = user_df['sentiment'].value_counts()\n    \n    # Package all statistics\n    report = {\n        'title': title,\n        'total_messages': total_messages,\n        'total_days': total_days,"
    },
    {
      "index": 176,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "28",
      "text": "'title': title,\n        'total_messages': total_messages,\n        'total_days': total_days,\n        'avg_messages_per_day': avg_messages_per_day,\n        'avg_message_length': avg_message_length,\n        'peak_hour': peak_hour,\n        'peak_day': peak_day,\n        'avg_sentiment': avg_sentiment,\n        'sentiment_distribution': sentiment_distribution\n    }\n    \n    return report"
    },
    {
      "index": 177,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "29",
      "text": "g_sentiment,\n        'sentiment_distribution': sentiment_distribution\n    }\n    \n    return report\n\ndef topic_sentiment_analysis(df):\n    \"\"\"Analyze sentiment by topic in messages\"\"\"\n    # Check if we have enough data\n    if len(df) < 20:  # Not enough data\n        return None\n    \n    # First get topic classifications\n    topic_messages, _ = conversation_topic_classifier(df)\n    \n    if topic_messages is None:\n        return None\n    \n    # Make sure sentiment_score column exists\n    if 'sentiment_score' not in topic_messages.columns:\n        return None\n    \n    # Group by topic and calculate average sentiment\n    topic_sentiment = topic_messages.groupby('topic').agg({\n        'sentiment_score': 'mean',\n        'Message': 'count'\n    }).reset_index()\n    \n    # Rename columns"
    },
    {
      "index": 178,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "30",
      "text": "sentiment_score': 'mean',\n        'Message': 'count'\n    }).reset_index()\n    \n    # Rename columns\n    topic_sentiment = topic_sentiment.rename(columns={\n        'sentiment_score': 'avg_sentiment',\n        'Message': 'message_count'\n    })\n    \n    # Filter for topics with enough messages for reliable sentiment\n    topic_sentiment = topic_sentiment[topic_sentiment['message_count'] >= 5]\n    \n    # If we have no topics with enough messages, return None\n    if topic_sentiment.empty:\n        return None\n    \n    # Convert topic numbers to topic labels\n    topic_sentiment['topic'] = topic_sentiment['topic'].apply(lambda x: f'Topic {x+1}')\n    \n    return topic_sentiment"
    },
    {
      "index": 179,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "31",
      "text": "topic'] = topic_sentiment['topic'].apply(lambda x: f'Topic {x+1}')\n    \n    return topic_sentiment\n\ndef conversation_tone_analysis(df):\n    \"\"\"Analyze the tone of conversations over time\"\"\"\n    # Check if we have enough data and required columns\n    if len(df) < 20 or 'sentiment_score' not in df.columns:\n        return None\n    \n    # Group by date and calculate average sentiment\n    daily_sentiment = df.groupby(df['Date'].dt.date).agg({\n        'sentiment_score': 'mean',\n        'Message': 'count'\n    }).reset_index()\n    \n    # Rename columns\n    daily_sentiment = daily_sentiment.rename(columns={\n        'sentiment_score': 'avg_sentiment',\n        'Message': 'message_count'\n    })\n    \n    # Calculate rolling average (7-day window)"
    },
    {
      "index": 180,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "32",
      "text": "ent',\n        'Message': 'message_count'\n    })\n    \n    # Calculate rolling average (7-day window)\n    daily_sentiment['rolling_sentiment'] = daily_sentiment['avg_sentiment'].rolling(window=7, min_periods=1).mean()\n    \n    # Identify tone shifts (days where sentiment changes significantly)\n    daily_sentiment['sentiment_shift'] = daily_sentiment['avg_sentiment'].diff()\n    \n    # Classify days by tone\n    daily_sentiment['tone'] = pd.cut(\n        daily_sentiment['avg_sentiment'],\n        bins=[-1, -0.3, 0.3, 1],\n        labels=['Negative', 'Neutral', 'Positive']\n    )\n    \n    # Calculate tone distribution\n    tone_distribution = daily_sentiment['tone'].value_counts().reset_index()\n    tone_distribution.columns = ['tone', 'count']\n    \n    # Calculate percentage of each tone"
    },
    {
      "index": 181,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "33",
      "text": "ex()\n    tone_distribution.columns = ['tone', 'count']\n    \n    # Calculate percentage of each tone\n    total_days = tone_distribution['count'].sum()\n    tone_distribution['percentage'] = tone_distribution['count'] / total_days * 100\n    \n    # Identify significant tone shifts\n    threshold = daily_sentiment['sentiment_shift'].std() * 1.5\n    significant_shifts = daily_sentiment[abs(daily_sentiment['sentiment_shift']) > threshold].copy()\n    \n    # Add shift direction\n    significant_shifts['shift_direction'] = significant_shifts['sentiment_shift'].apply(\n        lambda x: 'Positive' if x > 0 else 'Negative'\n    )\n    \n    # Filter for days with enough messages\n    daily_sentiment = daily_sentiment[daily_sentiment['message_count'] >= 5]\n    \n    # Return results\n    return {"
    },
    {
      "index": 182,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "34",
      "text": "ent = daily_sentiment[daily_sentiment['message_count'] >= 5]\n    \n    # Return results\n    return {\n        'daily_sentiment': daily_sentiment,\n        'tone_distribution': tone_distribution,\n        'significant_shifts': significant_shifts\n    }"
    },
    {
      "index": 183,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "35",
      "text": "'tone_distribution': tone_distribution,\n        'significant_shifts': significant_shifts\n    }\n\ndef user_communication_style(df):\n    \"\"\"Analyze communication style patterns for each user\"\"\"\n    if len(df) < 30:  # Not enough data\n        return None\n    \n    # Initialize user style dataframe\n    users = df['User'].unique()\n    \n    # Create a dictionary to store user styles\n    user_styles = []\n    \n    for user in users:\n        user_df = df[df['User'] == user]\n        \n        if len(user_df) < 10:  # Skip users with too few messages\n            continue\n            \n        # Calculate message length statistics\n        avg_length = user_df['message_length'].mean()\n        max_length = user_df['message_length'].max()\n        \n        # Calculate message frequency"
    },
    {
      "index": 184,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "36",
      "text": "max_length = user_df['message_length'].max()\n        \n        # Calculate message frequency\n        user_days = user_df['Date'].dt.date.nunique()\n        msgs_per_day = len(user_df) / user_days if user_days > 0 else 0\n        \n        # Calculate average sentiment (if available)\n        avg_sentiment = user_df['sentiment_score'].mean() if 'sentiment_score' in user_df.columns else 0\n        \n        # Calculate response time (if applicable)\n        response_times = df[df['prev_user'] == user]['response_time'] if 'response_time' in df.columns else None\n        avg_response_time = response_times.mean() if response_times is not None and len(response_times) > 0 else None\n        \n        # Calculate style metrics"
    },
    {
      "index": 185,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "37",
      "text": "not None and len(response_times) > 0 else None\n        \n        # Calculate style metrics\n        \n        # 1. Formality score (based on message length, punctuation, etc.)\n        # Check for formal language markers\n        formal_markers = ['please', 'thank you', 'regards', 'sincerely', 'would you', 'could you']\n        informal_markers = ['lol', 'haha', 'yeah', 'nah', 'btw', 'gonna', 'wanna']\n        \n        formality_score = 0.5  # Default neutral score\n        \n        # Count formal/informal markers\n        formal_count = sum(user_df['Message'].str.lower().str.contains(marker, regex=False).sum() \n                           for marker in formal_markers)\n        informal_count = sum(user_df['Message'].str.lower().str.contains(marker, regex=False).sum()"
    },
    {
      "index": 186,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "38",
      "text": "informal_count = sum(user_df['Message'].str.lower().str.contains(marker, regex=False).sum() \n                             for marker in informal_markers)\n        \n        # Adjust formality based on markers\n        total_markers = formal_count + informal_count\n        if total_markers > 0:\n            formality_score = min(1.0, max(0.0, 0.5 + 0.5 * (formal_count - informal_count) / total_markers))\n        \n        # Adjust formality based on message length (longer messages tend to be more formal)\n        if avg_length > 50:\n            formality_score = min(1.0, formality_score + 0.1)\n        elif avg_length < 15:\n            formality_score = max(0.0, formality_score - 0.1)\n        \n        # 2. Expressiveness (based on emoji usage, exclamations, etc.)"
    },
    {
      "index": 187,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "39",
      "text": "mality_score - 0.1)\n        \n        # 2. Expressiveness (based on emoji usage, exclamations, etc.)\n        expressiveness_score = 0.5  # Default neutral score\n        \n        # Count emojis if available\n        emoji_rate = user_df['emoji_count'].mean() if 'emoji_count' in user_df.columns else 0\n        \n        # Count exclamation marks\n        exclamation_rate = user_df['Message'].str.count('!').mean()\n        \n        # Count question marks\n        question_rate = user_df['Message'].str.count('\\\\?').mean()\n        \n        # Adjust expressiveness based on emoji and punctuation usage\n        expressiveness_score = min(1.0, max(0.0, 0.5 + 0.2 * emoji_rate + 0.1 * exclamation_rate + 0.05 * question_rate))"
    },
    {
      "index": 188,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "40",
      "text": "min(1.0, max(0.0, 0.5 + 0.2 * emoji_rate + 0.1 * exclamation_rate + 0.05 * question_rate))\n        \n        # 3. Complexity (based on message length, vocabulary diversity, etc.)\n        complexity_score = 0.5  # Default neutral score\n        \n        # Adjust complexity based on message length\n        if avg_length > 50:\n            complexity_score += 0.2\n        elif avg_length > 30:\n            complexity_score += 0.1\n        elif avg_length < 15:\n            complexity_score -= 0.1\n            \n        # Calculate vocabulary diversity (if messages are long enough)\n        if avg_length > 20:\n            # Get all words\n            all_words = ' '.join(user_df['Message']).lower().split()\n            # Calculate unique word ratio\n            if len(all_words) > 0:"
    },
    {
      "index": 189,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "41",
      "text": "age']).lower().split()\n            # Calculate unique word ratio\n            if len(all_words) > 0:\n                unique_ratio = len(set(all_words)) / len(all_words)\n                complexity_score += min(0.3, unique_ratio * 0.5)\n        \n        complexity_score = min(1.0, max(0.0, complexity_score))\n        \n        # 4. Politeness (based on thank you, please, etc.)\n        politeness_score = 0.5  # Default neutral score\n        \n        polite_markers = ['please', 'thank', 'thanks', 'appreciate', 'sorry', 'excuse']\n        polite_count = sum(user_df['Message'].str.lower().str.contains(marker, regex=False).sum() \n                           for marker in polite_markers)\n        \n        # Adjust politeness based on polite marker frequency"
    },
    {
      "index": 190,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "42",
      "text": "for marker in polite_markers)\n        \n        # Adjust politeness based on polite marker frequency\n        politeness_score += min(0.4, polite_count / len(user_df) * 0.8)\n        politeness_score = min(1.0, max(0.0, politeness_score))\n        \n        # 5. Directness (based on message length, question frequency, etc.)\n        directness_score = 0.5  # Default neutral score\n        \n        # Shorter messages tend to be more direct\n        if avg_length < 15:\n            directness_score += 0.2\n        elif avg_length > 50:\n            directness_score -= 0.1\n            \n        # Questions are usually less direct\n        if question_rate > 0.5:\n            directness_score -= 0.1\n            \n        # Check for directive language"
    },
    {
      "index": 191,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "43",
      "text": "rate > 0.5:\n            directness_score -= 0.1\n            \n        # Check for directive language\n        directive_markers = ['do this', 'please do', 'need to', 'should', 'must', 'have to']\n        directive_count = sum(user_df['Message'].str.lower().str.contains(marker, regex=False).sum() \n                              for marker in directive_markers)\n        \n        # Adjust directness based on directive marker frequency\n        directness_score += min(0.3, directive_count / len(user_df) * 0.6)\n        directness_score = min(1.0, max(0.0, directness_score))\n        \n        # Determine overall style traits\n        style_traits = []\n        \n        # Message length style\n        if avg_length < 15:\n            length_style = \"Concise\"\n        elif avg_length < 40:"
    },
    {
      "index": 192,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "44",
      "text": "tyle\n        if avg_length < 15:\n            length_style = \"Concise\"\n        elif avg_length < 40:\n            length_style = \"Moderate\"\n        else:\n            length_style = \"Detailed\"\n        style_traits.append(length_style)\n        \n        # Frequency style\n        if msgs_per_day < 3:\n            freq_style = \"Infrequent\"\n        elif msgs_per_day < 10:\n            freq_style = \"Regular\"\n        else:\n            freq_style = \"Frequent\"\n        style_traits.append(freq_style)\n        \n        # Sentiment style (if available)\n        if 'sentiment_score' in user_df.columns:\n            if avg_sentiment < -0.2:\n                sent_style = \"Negative\"\n            elif avg_sentiment > 0.2:\n                sent_style = \"Positive\"\n            else:"
    },
    {
      "index": 193,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "45",
      "text": "ve\"\n            elif avg_sentiment > 0.2:\n                sent_style = \"Positive\"\n            else:\n                sent_style = \"Neutral\"\n            style_traits.append(sent_style)\n        \n        # Store user style information\n        user_styles.append({\n            'User': user,\n            'message_count': len(user_df),\n            'avg_message_length': avg_length,\n            'max_message_length': max_length,\n            'msgs_per_day': msgs_per_day,\n            'avg_sentiment': avg_sentiment if 'sentiment_score' in user_df.columns else None,\n            'avg_response_time': avg_response_time,\n            'formality': formality_score,\n            'expressiveness': expressiveness_score,\n            'complexity': complexity_score,\n            'politeness': politeness_score,"
    },
    {
      "index": 194,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "46",
      "text": "ness_score,\n            'complexity': complexity_score,\n            'politeness': politeness_score,\n            'directness': directness_score,\n            'primary_style': \" & \".join(style_traits[:2]),  # Main style descriptor\n            'style_traits': style_traits\n        })\n    \n    # Convert to dataframe\n    user_styles_df = pd.DataFrame(user_styles)\n    \n    return user_styles_df"
    },
    {
      "index": 195,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "47",
      "text": "Convert to dataframe\n    user_styles_df = pd.DataFrame(user_styles)\n    \n    return user_styles_df\n\ndef extract_key_phrases(df):\n    \"\"\"Extract key phrases and topics from chat messages\"\"\"\n    \n    # Check if we have enough data\n    if len(df) < 20:  # Not enough data\n        return None\n    \n    # Get messages longer than 5 characters to avoid noise\n    long_messages = df[df['Message'].str.len() > 5]\n    \n    if len(long_messages) < 10:  # Not enough data\n        return None\n    \n    try:\n        # Convert messages to one text corpus\n        all_text = ' '.join(long_messages['Message'].tolist())\n        \n        # Basic preprocessing\n        # Remove URLs\n        import re\n        all_text = re.sub(r'http\\S+', '', all_text)\n        \n        # Convert to lowercase"
    },
    {
      "index": 196,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "48",
      "text": "port re\n        all_text = re.sub(r'http\\S+', '', all_text)\n        \n        # Convert to lowercase\n        all_text = all_text.lower()\n        \n        # Tokenize the text\n        import nltk\n        try:\n            nltk.data.find('tokenizers/punkt')\n        except LookupError:\n            nltk.download('punkt', quiet=True)\n            \n        try:\n            nltk.data.find('corpora/stopwords')\n        except LookupError:\n            nltk.download('stopwords', quiet=True)\n        \n        from nltk.corpus import stopwords\n        from nltk.tokenize import word_tokenize, sent_tokenize\n        \n        # Get stopwords\n        stop_words = set(stopwords.words('english'))\n        \n        # Tokenize by sentence, then by word\n        sentences = sent_tokenize(all_text)"
    },
    {
      "index": 197,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "49",
      "text": ")\n        \n        # Tokenize by sentence, then by word\n        sentences = sent_tokenize(all_text)\n        word_frequencies = {}\n        \n        for sentence in sentences:\n            words = word_tokenize(sentence)\n            \n            for word in words:\n                if word.lower() not in stop_words and word.isalnum() and len(word) > 2:\n                    if word not in word_frequencies:\n                        word_frequencies[word] = 1\n                    else:\n                        word_frequencies[word] += 1\n        \n        # Normalize word frequencies\n        max_frequency = max(word_frequencies.values()) if word_frequencies else 1\n        for word in word_frequencies:\n            word_frequencies[word] = word_frequencies[word] / max_frequency"
    },
    {
      "index": 198,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "50",
      "text": "d_frequencies:\n            word_frequencies[word] = word_frequencies[word] / max_frequency\n        \n        # Extract n-grams (phrases)\n        try:\n            from nltk.util import ngrams\n        except:\n            nltk.download('util', quiet=True)\n            from nltk.util import ngrams\n            \n        phrases = {}\n        \n        # Process each message separately\n        for message in long_messages['Message']:\n            # Clean and tokenize\n            clean_msg = re.sub(r'http\\S+', '', message.lower())\n            tokens = word_tokenize(clean_msg)\n            filtered_tokens = [word for word in tokens if word.lower() not in stop_words \n                              and word.isalnum() and len(word) > 2]\n            \n            # Extract bigrams and trigrams"
    },
    {
      "index": 199,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "51",
      "text": "and word.isalnum() and len(word) > 2]\n            \n            # Extract bigrams and trigrams\n            if len(filtered_tokens) >= 2:\n                message_bigrams = list(ngrams(filtered_tokens, 2))\n                for gram in message_bigrams:\n                    if gram in phrases:\n                        phrases[gram] += 1\n                    else:\n                        phrases[gram] = 1\n            \n            if len(filtered_tokens) >= 3:\n                message_trigrams = list(ngrams(filtered_tokens, 3))\n                for gram in message_trigrams:\n                    if gram in phrases:\n                        phrases[gram] += 1\n                    else:\n                        phrases[gram] = 1\n        \n        # Normalize phrase frequencies"
    },
    {
      "index": 200,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "52",
      "text": "else:\n                        phrases[gram] = 1\n        \n        # Normalize phrase frequencies\n        max_phrase_freq = max(phrases.values()) if phrases else 1\n        for phrase in phrases:\n            phrases[phrase] = phrases[phrase] / max_phrase_freq\n        \n        # Filter out less frequent phrases\n        min_freq = 0.1  # Minimum normalized frequency threshold\n        phrases = {phrase: score for phrase, score in phrases.items() if score >= min_freq}\n        \n        # Try to apply TextRank or similar algorithm if we can\n        # This uses a simplified scoring approach instead of full TextRank\n        # but gives reasonably good results for key phrase extraction\n        \n        # Score phrases by word importance\n        for phrase in list(phrases.keys()):"
    },
    {
      "index": 201,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "53",
      "text": "ion\n        \n        # Score phrases by word importance\n        for phrase in list(phrases.keys()):\n            phrase_words = phrase\n            phrase_score = sum(word_frequencies.get(word, 0) for word in phrase_words)\n            phrases[phrase] = phrase_score / len(phrase_words)\n        \n        # Return phrases sorted by score\n        return phrases\n        \n    except Exception as e:\n        print(f\"Error in key phrase extraction: {e}\")\n        return None"
    },
    {
      "index": 202,
      "filename": "ml_models.py",
      "filepath": "ChatIQ-main\\ml_models.py",
      "chunk_index": "54",
      "text": "except Exception as e:\n        print(f\"Error in key phrase extraction: {e}\")\n        return None"
    },
    {
      "index": 203,
      "filename": "pdf_exporter.py",
      "filepath": "ChatIQ-main\\pdf_exporter.py",
      "chunk_index": "0",
      "text": "import io\nimport matplotlib.pyplot as plt\nfrom fpdf import FPDF\nimport pandas as pd\n\ndef create_pdf_report(title, user_df, stats, charts=None):\n    pdf = FPDF()\n    pdf.add_page()\n\n    # Title\n    pdf.set_font('Arial', 'B', 16)\n    pdf.cell(0, 10, title, 0, 1, 'C')\n    pdf.ln(10)\n\n    # Stats Section\n    pdf.set_font('Arial', 'B', 14)\n    pdf.cell(0, 10, \"WhatsApp Chat Analysis Report\", 0, 1, 'L')\n    pdf.ln(5)\n    pdf.set_font('Arial', '', 12)\n\n    def add_stat_line(label, value):\n        if value is not None:\n            pdf.cell(0, 10, f\"{label}: {value}\", 0, 1, 'L')"
    },
    {
      "index": 204,
      "filename": "pdf_exporter.py",
      "filepath": "ChatIQ-main\\pdf_exporter.py",
      "chunk_index": "1",
      "text": "value):\n        if value is not None:\n            pdf.cell(0, 10, f\"{label}: {value}\", 0, 1, 'L')\n\n    add_stat_line(\"Total Messages\", stats.get('msg_count'))\n    add_stat_line(\"Total Users\", stats.get('user_count'))\n    add_stat_line(\"Date Range\", f\"{stats.get('days')} days\")\n    add_stat_line(\"Media Shared\", stats.get('media_cnt'))\n    add_stat_line(\"Words Exchanged\", stats.get('word_count'))\n    add_stat_line(\"Links Shared\", stats.get('links_cnt'))"
    },
    {
      "index": 205,
      "filename": "pdf_exporter.py",
      "filepath": "ChatIQ-main\\pdf_exporter.py",
      "chunk_index": "2",
      "text": "rds Exchanged\", stats.get('word_count'))\n    add_stat_line(\"Links Shared\", stats.get('links_cnt'))\n\n    # Most Active Users\n    if 'user_counts' in stats and isinstance(stats['user_counts'], pd.Series):\n        pdf.ln(10)\n        pdf.set_font('Arial', 'B', 14)\n        pdf.cell(0, 10, \"Most Active Users\", 0, 1, 'L')\n        pdf.set_font('Arial', '', 12)\n        for i, (user, count) in enumerate(stats['user_counts'].items()):\n            if i >= 5:\n                break\n            pdf.cell(0, 10, f\"{user}: {count} messages\", 0, 1, 'L')"
    },
    {
      "index": 206,
      "filename": "pdf_exporter.py",
      "filepath": "ChatIQ-main\\pdf_exporter.py",
      "chunk_index": "3",
      "text": "i >= 5:\n                break\n            pdf.cell(0, 10, f\"{user}: {count} messages\", 0, 1, 'L')\n\n    # Sentiment Analysis\n    if 'sentiment_counts' in stats and stats['sentiment_counts'] is not None:\n        pdf.ln(10)\n        pdf.set_font('Arial', 'B', 14)\n        pdf.cell(0, 10, \"Sentiment Analysis\", 0, 1, 'L')\n        pdf.set_font('Arial', '', 12)\n        for sentiment, count in stats['sentiment_counts'].items():\n            pdf.cell(0, 10, f\"{sentiment}: {count} messages\", 0, 1, 'L')"
    },
    {
      "index": 207,
      "filename": "pdf_exporter.py",
      "filepath": "ChatIQ-main\\pdf_exporter.py",
      "chunk_index": "4",
      "text": "ntiment_counts'].items():\n            pdf.cell(0, 10, f\"{sentiment}: {count} messages\", 0, 1, 'L')\n\n    # Add charts (if any)\n    if charts:\n        for chart in charts:\n            pdf.add_page()\n            img_buffer = io.BytesIO()\n            chart.savefig(img_buffer, format='png', bbox_inches='tight')\n            img_buffer.seek(0)\n            pdf.image(img_buffer, x=10, y=30, w=180)\n            plt.close(chart)\n\n    # Notes\n    pdf.add_page()\n    pdf.set_font('Arial', 'B', 14)\n    pdf.cell(0, 10, \"Analysis Notes\", 0, 1, 'L')\n    pdf.set_font('Arial', '', 12)\n    pdf.multi_cell(0, 10, \"This report was generated using WhatsApp Chat Analyzer Pro. \"\n                         \"It includes user engagement, sentiment insights, and basic stats.\")"
    },
    {
      "index": 208,
      "filename": "pdf_exporter.py",
      "filepath": "ChatIQ-main\\pdf_exporter.py",
      "chunk_index": "5",
      "text": "o. \"\n                         \"It includes user engagement, sentiment insights, and basic stats.\")\n\n    # Return as bytes\n    try:\n        return pdf.output(dest='S').encode('latin-1')  # proper PDF byte encoding\n    except Exception as e:\n        print(f\"[PDF ERROR] {e}\")\n        return b\"\""
    },
    {
      "index": 209,
      "filename": "pdf_exporter.py",
      "filepath": "ChatIQ-main\\pdf_exporter.py",
      "chunk_index": "6",
      "text": "byte encoding\n    except Exception as e:\n        print(f\"[PDF ERROR] {e}\")\n        return b\"\"\n    \n\ndef generate_report_pdf(df, title, user_name, stats):\n    report_stats = {\n        'msg_count': stats.get('msg_count', 0),\n        'user_count': len(df['User'].unique()),\n        'days': df['Date'].nunique(),\n        'media_cnt': stats.get('media_cnt', 0),\n        'word_count': stats.get('word_count', 0),\n        'links_cnt': stats.get('links_cnt', 0),\n        'user_counts': df['User'].value_counts() if user_name == 'Everyone' else pd.Series(),\n        'sentiment_counts': df['sentiment'].value_counts() if 'sentiment' in df.columns else None\n    }\n\n    pdf_title = f\"WhatsApp Chat Analysis: {user_name}\"\n    return create_pdf_report(pdf_title, df, report_stats)"
    },
    {
      "index": 210,
      "filename": "pdf_exporter.py",
      "filepath": "ChatIQ-main\\pdf_exporter.py",
      "chunk_index": "7",
      "text": "e = f\"WhatsApp Chat Analysis: {user_name}\"\n    return create_pdf_report(pdf_title, df, report_stats)"
    },
    {
      "index": 211,
      "filename": "README.md",
      "filepath": "ChatIQ-main\\README.md",
      "chunk_index": "0",
      "text": "# üìå Chat Analytics Pro ‚Äì Advanced Chat Data Analysis Using NLP & ML  \n\n## üìÇ Project Overview  \nChat Analytics Pro is a powerful **Natural Language Processing (NLP)** and **Machine Learning (ML)** tool designed to analyze chat data, extract key insights, detect conversation patterns, and predict future trends.  \n\nThis tool provides **in-depth chat analytics**, **user engagement insights**, **sentiment analysis**, and **trend forecasting** for any conversation dataset.  \n\n---"
    },
    {
      "index": 212,
      "filename": "README.md",
      "filepath": "ChatIQ-main\\README.md",
      "chunk_index": "1",
      "text": "insights**, **sentiment analysis**, and **trend forecasting** for any conversation dataset.  \n\n---\n\n## üìå Key Features  \n‚úî **User Engagement Analysis** ‚Äì Identifies the most active users in a chat.  \n‚úî **Sentiment Analysis** ‚Äì Detects if messages are **Positive, Neutral, or Negative**.  \n‚úî **Topic Modeling** ‚Äì Finds the main discussion topics using NLP.  \n‚úî **Message Frequency Forecasting** ‚Äì Uses **Machine Learning (Facebook Prophet)** to predict future chat activity.  \n‚úî **Message Intensity Trends** ‚Äì Shows chat activity trends over time with **7-day & 30-day moving averages**.  \n‚úî **User Clustering** ‚Äì Groups users based on chat behavior using **K-Means Clustering**.  \n‚úî **Visual Insights** ‚Äì Generates **interactive heatmaps, word clouds, and trend graphs**.  \n\n---"
    },
    {
      "index": 213,
      "filename": "README.md",
      "filepath": "ChatIQ-main\\README.md",
      "chunk_index": "2",
      "text": "‚úî **Visual Insights** ‚Äì Generates **interactive heatmaps, word clouds, and trend graphs**.  \n\n---\n\n## üõ†Ô∏è Tech Stack  \nüîπ **Backend:** Python, Pandas, NumPy, Flask  \nüîπ **Machine Learning:** Scikit-learn, Facebook Prophet, NLP (TextBlob, NLTK)  \nüîπ **Data Visualization:** Matplotlib, Seaborn, Plotly, Streamlit  \nüîπ **Frontend:** Streamlit (for interactive UI)  \n\n---\n\n## üìå Installation & Setup"
    },
    {
      "index": 214,
      "filename": "README.md",
      "filepath": "ChatIQ-main\\README.md",
      "chunk_index": "3",
      "text": "ly, Streamlit  \nüîπ **Frontend:** Streamlit (for interactive UI)  \n\n---\n\n## üìå Installation & Setup  \n\n### 1Ô∏è‚É£ Clone the Repository  \n```sh\ngit clone https://github.com/your-username/Chat-Analytics-Pro.git\ncd Chat-Analytics-Pro\n```\n### 2Ô∏è‚É£ Create a Virtual Environment (Optional but Recommended)\n```sh\nCopy\nEdit\n# On macOS/Linux\npython -m venv venv\nsource venv/bin/activate\n```\n## On Windows\n```\npython -m venv venv\nvenv\\Scripts\\activate\n```\n### 3Ô∏è‚É£ Install Required Dependencies\n```sh\nCopy\nEdit\npip install -r requirements.txt\n```\n### 4Ô∏è‚É£ Run the Application\n```sh\nCopy\nEdit\nstreamlit run main.py\n```\n‚úÖ Open: http://localhost:8501/ in your browser to view the dashboard."
    },
    {
      "index": 215,
      "filename": "README.md",
      "filepath": "ChatIQ-main\\README.md",
      "chunk_index": "4",
      "text": "it\nstreamlit run main.py\n```\n‚úÖ Open: http://localhost:8501/ in your browser to view the dashboard.\n\n## üìå Future Enhancements  \nüöÄ Planned features for future updates:  \nüîπ **Real-time chat analysis** for live conversations.  \nüîπ **Multi-platform support** (Telegram, Slack, Discord chat data analysis).  \nüîπ **AI-based auto-replies and chatbot integration**.  \nüîπ **Customizable chat analytics reports**.  \n\n---\n\n## üìú License  \nüìå This project is **open-source under the MIT License**. Feel free to contribute!  \n\n---\n\n## üì© Contact & Contributions  \nüìå Contributions, feedback, and suggestions are welcome!  \n\nüîó **[GitHub Issues](https://github.com/your-username/Chat-Analytics-Pro/issues)** ‚Äì Report bugs or request features.  \nüîó **Pull Requests** ‚Äì Submit improvements and fixes.  \n\n---"
    },
    {
      "index": 216,
      "filename": "README.md",
      "filepath": "ChatIQ-main\\README.md",
      "chunk_index": "5",
      "text": "* ‚Äì Report bugs or request features.  \nüîó **Pull Requests** ‚Äì Submit improvements and fixes.  \n\n---\n\nüöÄ **Chat Analytics Pro ‚Äì Unlock Insights from Your Conversations!** üéØ"
    },
    {
      "index": 217,
      "filename": "README.md",
      "filepath": "ChatIQ-main\\README.md",
      "chunk_index": "6",
      "text": "mprovements and fixes.  \n\n---\n\nüöÄ **Chat Analytics Pro ‚Äì Unlock Insights from Your Conversations!** üéØ"
    },
    {
      "index": 218,
      "filename": "requirements.txt",
      "filepath": "ChatIQ-main\\requirements.txt",
      "chunk_index": "0",
      "text": "streamlit\nmatplotlib\nurlextract\nseaborn\nwordcloud\npandas\nemoji\nnetworkx\nnltk\nnumpy\nplotly\nprophet\nscikit-learn\ntextblob\nfpdf\nXlsxWriter"
    },
    {
      "index": 219,
      "filename": "setup.sh",
      "filepath": "ChatIQ-main\\setup.sh",
      "chunk_index": "0",
      "text": "mkdir -p ~/.streamlit/\necho \"\\\n[server]\\n\\\nport = $PORT\\n\\\nenableCORS = false\\n\\\nheadless = true\\n\\\n\\n\\\n\" > ~/.streamlit/config.toml"
    },
    {
      "index": 220,
      "filename": "stop_hinglish.txt",
      "filepath": "ChatIQ-main\\stop_hinglish.txt",
      "chunk_index": "0",
      "text": ".\n..\n...\n?\n-\n--\n1\n2\n3\n4\n5\n6\n7\n8\n9\n0\na\naadi\naaj\naap\naapne\naata\naati\naaya\naaye\nab\nabbe\nabbey\nabe\nabhi\nable\nabout\nabove\naccha\naccording\naccordingly\nacha\nachcha\nacross\nactually\nafter\nafterwards\nagain\nagainst\nagar\nain\naint\nain't\naisa\naise\naisi\nalag\nall\nallow\nallows\nalmost\nalone\nalong\nalready\nalso\nalthough\nalways\nam\namong\namongst\nan\nand\nandar\nanother\nany\nanybody\nanyhow\nanyone\nanything\nanyway\nanyways\nanywhere\nap\napan\napart\napna\napnaa\napne\napni\nappear\nare\naren\narent\naren't\naround\narre\nas\naside\nask\nasking\nat\naur\navum\naya\naye\nbaad\nbaar\nbad\nbahut\nbana\nbanae\nbanai\nbanao\nbanaya\nbanaye\nbanayi\nbanda\nbande\nbandi\nbane\nbani\nbas\nbata\nbatao\nbc\nbe\nbecame\nbecause\nbecome\nbecomes\nbecoming\nbeen\nbefore\nbeforehand\nbehind\nbeing\nbelow\nbeside\nbesides\nbest\nbetter\nbetween\nbeyond\nbhai\nbheetar\nbhi\nbhitar\nbht\nbilkul\nbohot"
    },
    {
      "index": 221,
      "filename": "stop_hinglish.txt",
      "filepath": "ChatIQ-main\\stop_hinglish.txt",
      "chunk_index": "1",
      "text": "hind\nbeing\nbelow\nbeside\nbesides\nbest\nbetter\nbetween\nbeyond\nbhai\nbheetar\nbhi\nbhitar\nbht\nbilkul\nbohot\nbol\nbola\nbole\nboli\nbolo\nbolta\nbolte\nbolti\nboth\nbrief\nbro\nbtw\nbut\nby\ncame\ncan\ncannot\ncant\ncan't\ncause\ncauses\ncertain\ncertainly\nchahiye\nchaiye\nchal\nchalega\nchhaiye\nclearly\nc'mon\ncom\ncome\ncomes\ncould\ncouldn\ncouldnt\ncouldn't\nd\nde\ndede\ndega\ndegi\ndekh\ndekha\ndekhe\ndekhi\ndekho\ndenge\ndhang\ndi\ndid\ndidn\ndidnt\ndidn't\ndijiye\ndiya\ndiyaa\ndiye\ndiyo\ndo\ndoes\ndoesn\ndoesnt\ndoesn't\ndoing\ndone\ndono\ndont\ndon't\ndoosra\ndoosre\ndown\ndownwards\ndude\ndunga\ndungi\nduring\ndusra\ndusre\ndusri\ndvaara\ndvara\ndwaara\ndwara\neach\nedu\neg\neight\neither\nek\nelse\nelsewhere\nenough\netc\neven\never\nevery\neverybody\neveryone\neverything\neverywhere\nex\nexactly\nexample\nexcept\nfar\nfew\nfifth\nfir\nfirst\nfive\nfollowed\nfollowing\nfollows\nfor\nforth\nfour"
    },
    {
      "index": 222,
      "filename": "stop_hinglish.txt",
      "filepath": "ChatIQ-main\\stop_hinglish.txt",
      "chunk_index": "2",
      "text": "re\nex\nexactly\nexample\nexcept\nfar\nfew\nfifth\nfir\nfirst\nfive\nfollowed\nfollowing\nfollows\nfor\nforth\nfour\nfrom\nfurther\nfurthermore\ngaya\ngaye\ngayi\nget\ngets\ngetting\nghar\ngiven\ngives\ngo\ngoes\ngoing\ngone\ngood\ngot\ngotten\ngreetings\nguys\nhaan\nhad\nhadd\nhadn\nhadnt\nhadn't\nhai\nhain\nhamara\nhamare\nhamari\nhamne\nhan\nhappens\nhar\nhardly\nhas\nhasn\nhasnt\nhasn't\nhave\nhaven\nhavent\nhaven't\nhaving\nhe\nhello\nhelp\nhence\nher\nhere\nhereafter\nhereby\nherein\nhere's\nhereupon\nhers\nherself\nhe's\nhi\nhim\nhimself\nhis\nhither\nhm\nhmm\nho\nhoga\nhoge\nhogi\nhona\nhonaa\nhone\nhonge\nhongi\nhoni\nhopefully\nhota\nhotaa\nhote\nhoti\nhow\nhowbeit\nhowever\nhoyenge\nhoyengi\nhu\nhua\nhue\nhuh\nhui\nhum\nhumein\nhumne\nhun\nhuye\nhuyi\ni\ni'd\nidk\nie\nif\ni'll\ni'm\nimo\nin\ninasmuch\ninc\ninhe\ninhi\ninho\ninka\ninkaa\ninke\ninki\ninn\ninner\ninse\ninsofar\ninto\ninward\nis\nise\nisi\niska\niskaa"
    },
    {
      "index": 223,
      "filename": "stop_hinglish.txt",
      "filepath": "ChatIQ-main\\stop_hinglish.txt",
      "chunk_index": "3",
      "text": "ch\ninc\ninhe\ninhi\ninho\ninka\ninkaa\ninke\ninki\ninn\ninner\ninse\ninsofar\ninto\ninward\nis\nise\nisi\niska\niskaa\niske\niski\nisme\nisn\nisne\nisnt\nisn't\niss\nisse\nissi\nisski\nit\nit'd\nit'll\nitna\nitne\nitni\nitno\nits\nit's\nitself\nityaadi\nityadi\ni've\nja\njaa\njab\njabh\njaha\njahaan\njahan\njaisa\njaise\njaisi\njata\njayega\njidhar\njin\njinhe\njinhi\njinho\njinhone\njinka\njinke\njinki\njinn\njis\njise\njiska\njiske\njiski\njisme\njiss\njisse\njitna\njitne\njitni\njo\njust\njyaada\njyada\nk\nka\nkaafi\nkab\nkabhi\nkafi\nkaha\nkahaa\nkahaan\nkahan\nkahi\nkahin\nkahte\nkaisa\nkaise\nkaisi\nkal\nkam\nkar\nkara\nkare\nkarega\nkaregi\nkaren\nkarenge\nkari\nkarke\nkarna\nkarne\nkarni\nkaro\nkarta\nkarte\nkarti\nkaru\nkarun\nkarunga\nkarungi\nkaun\nkaunsa\nkayi\nkch\nke\nkeep\nkeeps\nkeh\nkehte\nkept\nkhud\nki\nkin\nkine\nkinhe\nkinho\nkinka\nkinke\nkinki\nkinko\nkinn\nkino\nkis\nkise\nkisi\nkiska\nkiske\nkiski\nkisko"
    },
    {
      "index": 224,
      "filename": "stop_hinglish.txt",
      "filepath": "ChatIQ-main\\stop_hinglish.txt",
      "chunk_index": "4",
      "text": "hud\nki\nkin\nkine\nkinhe\nkinho\nkinka\nkinke\nkinki\nkinko\nkinn\nkino\nkis\nkise\nkisi\nkiska\nkiske\nkiski\nkisko\nkisliye\nkisne\nkitna\nkitne\nkitni\nkitno\nkiya\nkiye\nknow\nknown\nknows\nko\nkoi\nkon\nkonsa\nkoyi\nkrna\nkrne\nkuch\nkuchch\nkuchh\nkul\nkull\nkya\nkyaa\nkyu\nkyuki\nkyun\nkyunki\nlagta\nlagte\nlagti\nlast\nlately\nlater\nle\nleast\nlekar\nlekin\nless\nlest\nlet\nlet's\nli\nlike\nliked\nlikely\nlittle\nliya\nliye\nll\nlo\nlog\nlogon\nlol\nlook\nlooking\nlooks\nltd\nlunga\nm\nmaan\nmaana\nmaane\nmaani\nmaano\nmagar\nmai\nmain\nmaine\nmainly\nmana\nmane\nmani\nmano\nmany\nmat\nmay\nmaybe\nme\nmean\nmeanwhile\nmein\nmera\nmere\nmerely\nmeri\nmight\nmightn\nmightnt\nmightn't\nmil\nmjhe\nmore\nmoreover\nmost\nmostly\nmuch\nmujhe\nmust\nmustn\nmustnt\nmustn't\nmy\nmyself\nna\nnaa\nnaah\nnahi\nnahin\nnai\nname\nnamely\nnd\nne\nnear\nnearly\nnecessary\nneeche\nneed\nneedn\nneednt\nneedn't\nneeds\nneither\nnever"
    },
    {
      "index": 225,
      "filename": "stop_hinglish.txt",
      "filepath": "ChatIQ-main\\stop_hinglish.txt",
      "chunk_index": "5",
      "text": "in\nnai\nname\nnamely\nnd\nne\nnear\nnearly\nnecessary\nneeche\nneed\nneedn\nneednt\nneedn't\nneeds\nneither\nnever\nnevertheless\nnew\nnext\nnhi\nnine\nno\nnobody\nnon\nnone\nnoone\nnope\nnor\nnormally\nnot\nnothing\nnovel\nnow\nnowhere\no\nobviously\nof\noff\noften\noh\nok\nokay\nold\non\nonce\none\nones\nonly\nonto\nor\nother\nothers\notherwise\nought\nour\nours\nourselves\nout\noutside\nover\noverall\nown\npar\npata\npe\npehla\npehle\npehli\npeople\nper\nperhaps\nphla\nphle\nphli\nplaced\nplease\nplus\npoora\npoori\nprovides\npura\npuri\nq\nque\nquite\nraha\nrahaa\nrahe\nrahi\nrakh\nrakha\nrakhe\nrakhen\nrakhi\nrakho\nrather\nre\nreally\nreasonably\nregarding\nregardless\nregards\nrehte\nrha\nrhaa\nrhe\nrhi\nri\nright\ns\nsa\nsaara\nsaare\nsaath\nsab\nsabhi\nsabse\nsahi\nsaid\nsakta\nsaktaa\nsakte\nsakti\nsame\nsang\nsara\nsath\nsaw\nsay\nsaying\nsays\nse\nsecond\nsecondly\nsee\nseeing\nseem\nseemed\nseeming\nseems\nseen"
    },
    {
      "index": 226,
      "filename": "stop_hinglish.txt",
      "filepath": "ChatIQ-main\\stop_hinglish.txt",
      "chunk_index": "6",
      "text": "ame\nsang\nsara\nsath\nsaw\nsay\nsaying\nsays\nse\nsecond\nsecondly\nsee\nseeing\nseem\nseemed\nseeming\nseems\nseen\nself\nselves\nsensible\nsent\nserious\nseriously\nseven\nseveral\nshall\nshan\nshant\nshan't\nshe\nshe's\nshould\nshouldn\nshouldnt\nshouldn't\nshould've\nsi\nsir\nsir.\nsince\nsix\nso\nsoch\nsome\nsomebody\nsomehow\nsomeone\nsomething\nsometime\nsometimes\nsomewhat\nsomewhere\nsoon\nstill\nsub\nsuch\nsup\nsure\nt\ntab\ntabh\ntak\ntake\ntaken\ntarah\nteen\nteeno\nteesra\nteesre\nteesri\ntell\ntends\ntera\ntere\nteri\nth\ntha\nthan\nthank\nthanks\nthanx\nthat\nthat'll\nthats\nthat's\nthe\ntheek\ntheir\ntheirs\nthem\nthemselves\nthen\nthence\nthere\nthereafter\nthereby\ntherefore\ntherein\ntheres\nthere's\nthereupon\nthese\nthey\nthey'd\nthey'll\nthey're\nthey've\nthi\nthik\nthing\nthink\nthinking\nthird\nthis\ntho\nthoda\nthodi\nthorough\nthoroughly\nthose\nthough\nthought\nthree\nthrough"
    },
    {
      "index": 227,
      "filename": "stop_hinglish.txt",
      "filepath": "ChatIQ-main\\stop_hinglish.txt",
      "chunk_index": "7",
      "text": "ng\nthink\nthinking\nthird\nthis\ntho\nthoda\nthodi\nthorough\nthoroughly\nthose\nthough\nthought\nthree\nthrough\nthroughout\nthru\nthus\ntjhe\nto\ntogether\ntoh\ntoo\ntook\ntoward\ntowards\ntried\ntries\ntrue\ntruly\ntry\ntrying\ntu\ntujhe\ntum\ntumhara\ntumhare\ntumhari\ntune\ntwice\ntwo\num\numm\nun\nunder\nunhe\nunhi\nunho\nunhone\nunka\nunkaa\nunke\nunki\nunko\nunless\nunlikely\nunn\nunse\nuntil\nunto\nup\nupar\nupon\nus\nuse\nused\nuseful\nuses\nusi\nusing\nuska\nuske\nusne\nuss\nusse\nussi\nusually\nvaala\nvaale\nvaali\nvahaan\nvahan\nvahi\nvahin\nvaisa\nvaise\nvaisi\nvala\nvale\nvali\nvarious\nve\nvery\nvia\nviz\nvo\nwaala\nwaale\nwaali\nwagaira\nwagairah\nwagerah\nwaha\nwahaan\nwahan\nwahi\nwahin\nwaisa\nwaise\nwaisi\nwala\nwale\nwali\nwant\nwants\nwas\nwasn\nwasnt\nwasn't\nway\nwe\nwe'd\nwell\nwe'll\nwent\nwere\nwe're\nweren\nwerent\nweren't\nwe've\nwhat\nwhatever\nwhat's\nwhen\nwhence\nwhenever\nwhere"
    },
    {
      "index": 228,
      "filename": "stop_hinglish.txt",
      "filepath": "ChatIQ-main\\stop_hinglish.txt",
      "chunk_index": "8",
      "text": "ll\nwe'll\nwent\nwere\nwe're\nweren\nwerent\nweren't\nwe've\nwhat\nwhatever\nwhat's\nwhen\nwhence\nwhenever\nwhere\nwhereafter\nwhereas\nwhereby\nwherein\nwhere's\nwhereupon\nwherever\nwhether\nwhich\nwhile\nwho\nwhoever\nwhole\nwhom\nwho's\nwhose\nwhy\nwill\nwilling\nwith\nwithin\nwithout\nwo\nwoh\nwohi\nwon\nwont\nwon't\nwould\nwouldn\nwouldnt\nwouldn't\ny\nya\nyadi\nyah\nyaha\nyahaan\nyahan\nyahi\nyahin\nye\nyeah\nyeh\nyehi\nyes\nyet\nyou\nyou'd\nyou'll\nyour\nyou're\nyours\nyourself\nyourselves\nyou've\nyup"
    },
    {
      "index": 229,
      "filename": "stop_hinglish.txt",
      "filepath": "ChatIQ-main\\stop_hinglish.txt",
      "chunk_index": "9",
      "text": "ahi\nyahin\nye\nyeah\nyeh\nyehi\nyes\nyet\nyou\nyou'd\nyou'll\nyour\nyou're\nyours\nyourself\nyourselves\nyou've\nyup"
    },
    {
      "index": 230,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "0",
      "text": "import streamlit as st\n\n# Define enhanced theme presets with more sophisticated color schemes\nTHEMES = {\n    \"Professional\": {\n        \"primaryColor\": \"#0063B2\",\n        \"backgroundColor\": \"#FFFFFF\",\n        \"secondaryBackgroundColor\": \"#F5F7FA\",\n        \"textColor\": \"#2C3E50\",\n        \"accentColor\": \"#9DC6E0\",\n        \"font\": \"Inter, sans-serif\",\n        \"borderRadius\": \"6px\",\n        \"boxShadow\": \"0 2px 10px rgba(0, 0, 0, 0.08)\"\n    },\n    \"Dark Pro\": {\n        \"primaryColor\": \"#7C4DFF\",\n        \"backgroundColor\": \"#1E1E2E\",\n        \"secondaryBackgroundColor\": \"#2D2D3F\",\n        \"textColor\": \"#E0E0E0\",\n        \"accentColor\": \"#B39DDB\",\n        \"font\": \"Inter, sans-serif\",\n        \"borderRadius\": \"8px\",\n        \"boxShadow\": \"0 4px 12px rgba(0, 0, 0, 0.15)\"\n    },\n    \"Midnight Blue\": {"
    },
    {
      "index": 231,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "1",
      "text": "Radius\": \"8px\",\n        \"boxShadow\": \"0 4px 12px rgba(0, 0, 0, 0.15)\"\n    },\n    \"Midnight Blue\": {\n        \"primaryColor\": \"#3498DB\",\n        \"backgroundColor\": \"#0A192F\",\n        \"secondaryBackgroundColor\": \"#172A45\",\n        \"textColor\": \"#E6F1FF\",\n        \"accentColor\": \"#64FFDA\",\n        \"font\": \"SF Pro Display, sans-serif\",\n        \"borderRadius\": \"6px\",\n        \"boxShadow\": \"0 3px 8px rgba(0, 0, 0, 0.3)\"\n    },\n    \"Ocean Breeze\": {\n        \"primaryColor\": \"#00B4D8\",\n        \"backgroundColor\": \"#F0F8FF\",\n        \"secondaryBackgroundColor\": \"#E1F5FE\",\n        \"textColor\": \"#263238\",\n        \"accentColor\": \"#90E0EF\",\n        \"font\": \"Nunito, sans-serif\",\n        \"borderRadius\": \"10px\",\n        \"boxShadow\": \"0 4px 6px rgba(0, 99, 178, 0.1)\"\n    },\n    \"Sunset Horizon\": {"
    },
    {
      "index": 232,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "2",
      "text": "ius\": \"10px\",\n        \"boxShadow\": \"0 4px 6px rgba(0, 99, 178, 0.1)\"\n    },\n    \"Sunset Horizon\": {\n        \"primaryColor\": \"#F76B1C\",\n        \"backgroundColor\": \"#FFFAF0\",\n        \"secondaryBackgroundColor\": \"#FFF1E6\",\n        \"textColor\": \"#4A4A4A\",\n        \"accentColor\": \"#FFC288\",\n        \"font\": \"Poppins, sans-serif\",\n        \"borderRadius\": \"8px\",\n        \"boxShadow\": \"0 3px 10px rgba(247, 107, 28, 0.08)\"\n    },\n    \"Minimal Elegance\": {\n        \"primaryColor\": \"#555B6E\",\n        \"backgroundColor\": \"#FCFCFC\",\n        \"secondaryBackgroundColor\": \"#F4F4F8\",\n        \"textColor\": \"#2B2D42\",\n        \"accentColor\": \"#BEC1CC\",\n        \"font\": \"Roboto, sans-serif\",\n        \"borderRadius\": \"4px\",\n        \"boxShadow\": \"0 2px 8px rgba(0, 0, 0, 0.05)\"\n    },\n    \"Forest Green\": {"
    },
    {
      "index": 233,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "3",
      "text": "erRadius\": \"4px\",\n        \"boxShadow\": \"0 2px 8px rgba(0, 0, 0, 0.05)\"\n    },\n    \"Forest Green\": {\n        \"primaryColor\": \"#2E7D32\",\n        \"backgroundColor\": \"#F8FBF6\",\n        \"secondaryBackgroundColor\": \"#E8F5E9\",\n        \"textColor\": \"#1B5E20\",\n        \"accentColor\": \"#A5D6A7\",\n        \"font\": \"Montserrat, sans-serif\",\n        \"borderRadius\": \"6px\",\n        \"boxShadow\": \"0 3px 8px rgba(46, 125, 50, 0.08)\"\n    },\n    \"Corporate Purple\": {\n        \"primaryColor\": \"#673AB7\",\n        \"backgroundColor\": \"#FFFFFF\",\n        \"secondaryBackgroundColor\": \"#F5F0FF\",\n        \"textColor\": \"#37474F\",\n        \"accentColor\": \"#D1C4E9\",\n        \"font\": \"Lato, sans-serif\",\n        \"borderRadius\": \"6px\",\n        \"boxShadow\": \"0 3px 10px rgba(103, 58, 183, 0.1)\"\n    }\n}"
    },
    {
      "index": 234,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "4",
      "text": ",\n        \"borderRadius\": \"6px\",\n        \"boxShadow\": \"0 3px 10px rgba(103, 58, 183, 0.1)\"\n    }\n}\n\ndef apply_theme():\n    \"\"\"\n    Apply the currently selected theme to the app with enhanced styling\n    \"\"\"\n    # Get the current theme name from session state\n    theme_name = st.session_state.get(\"theme\", \"Professional\")\n    \n    # Get theme colors and properties\n    theme = THEMES[theme_name]\n    \n    # Apply theme using CSS with enhanced styling\n    st.markdown(f\"\"\"\n    <style>\n        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Montserrat:wght@400;500;600&family=Nunito:wght@400;600;700&family=Poppins:wght@400;500;600&family=Roboto:wght@400;500&family=Lato:wght@400;700&display=swap');\n        \n        /* Global Styles */\n        * {{"
    },
    {
      "index": 235,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "5",
      "text": "@400;500&family=Lato:wght@400;700&display=swap');\n        \n        /* Global Styles */\n        * {{\n            transition: all 0.2s ease;\n        }}\n        \n        /* Main App */\n        .stApp {{\n            background-color: {theme[\"backgroundColor\"]};\n            color: {theme[\"textColor\"]};\n            font-family: {theme[\"font\"]};\n        }}\n        \n        /* Sidebar */\n        section[data-testid=\"stSidebar\"] {{\n            background-color: {theme[\"secondaryBackgroundColor\"]};\n            border-right: 1px solid rgba(0,0,0,0.05);\n            padding: 1rem 0;\n        }}\n        \n        /* Sidebar Title */\n        .sidebar .sidebar-content .block-container h1 {{\n            color: {theme[\"primaryColor\"]};\n            font-weight: 600;\n            font-size: 1.25rem;"
    },
    {
      "index": 236,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "6",
      "text": "color: {theme[\"primaryColor\"]};\n            font-weight: 600;\n            font-size: 1.25rem;\n            margin-bottom: 1.5rem;\n        }}\n        \n        /* Cards and containers */\n        div.stCard {{\n            background-color: {theme[\"secondaryBackgroundColor\"]};\n            border-radius: {theme[\"borderRadius\"]};\n            padding: 20px;\n            margin-bottom: 15px;\n            box-shadow: {theme[\"boxShadow\"]};\n            border: 1px solid rgba(0,0,0,0.03);\n        }}\n        \n        /* Custom metric cards */\n        .metric-card {{\n            background-color: {theme[\"secondaryBackgroundColor\"]};\n            border-left: 4px solid {theme[\"primaryColor\"]};\n            padding: 16px;\n            border-radius: {theme[\"borderRadius\"]};"
    },
    {
      "index": 237,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "7",
      "text": "me[\"primaryColor\"]};\n            padding: 16px;\n            border-radius: {theme[\"borderRadius\"]};\n            box-shadow: {theme[\"boxShadow\"]};\n            transition: transform 0.2s ease;\n        }}\n        \n        .metric-card:hover {{\n            transform: translateY(-2px);\n            box-shadow: 0 6px 12px rgba(0,0,0,0.1);\n        }}\n        \n        /* Headers and titles */\n        h1 {{\n            color: {theme[\"primaryColor\"]};\n            font-weight: 600;\n            font-size: 2rem;\n            margin-bottom: 1rem;\n        }}\n        \n        h2 {{\n            color: {theme[\"primaryColor\"]};\n            font-weight: 500;\n            font-size: 1.5rem;\n            margin-bottom: 0.75rem;\n        }}\n        \n        h3, h4, h5, h6 {{\n            color: {theme[\"textColor\"]};"
    },
    {
      "index": 238,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "8",
      "text": "om: 0.75rem;\n        }}\n        \n        h3, h4, h5, h6 {{\n            color: {theme[\"textColor\"]};\n            font-weight: 500;\n        }}\n        \n        /* Links */\n        a {{\n            color: {theme[\"primaryColor\"]};\n            text-decoration: none;\n            transition: color 0.2s ease;\n        }}\n        \n        a:hover {{\n            color: {theme[\"accentColor\"]};\n            text-decoration: underline;\n        }}\n        \n        /* Buttons */\n        button[data-baseweb=\"button\"] {{\n            background-color: {theme[\"primaryColor\"]};\n            border-radius: {theme[\"borderRadius\"]};\n            transition: all 0.2s ease;\n            font-weight: 500;\n            border: none;\n        }}\n        \n        button[data-baseweb=\"button\"]:hover {{"
    },
    {
      "index": 239,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "9",
      "text": ": 500;\n            border: none;\n        }}\n        \n        button[data-baseweb=\"button\"]:hover {{\n            background-color: {theme[\"primaryColor\"]}E6;\n            transform: translateY(-1px);\n            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n        }}\n        \n        /* Dropdown menus */\n        div[data-baseweb=\"select\"] {{\n            background-color: {theme[\"secondaryBackgroundColor\"]};\n            border-radius: {theme[\"borderRadius\"]};\n            border: 1px solid rgba(0,0,0,0.1);\n        }}\n        \n        /* Navigation pills */\n        button[role=\"tab\"] {{\n            background-color: {theme[\"secondaryBackgroundColor\"]};\n            color: {theme[\"textColor\"]};\n            border-radius: {theme[\"borderRadius\"]};\n            border: none;"
    },
    {
      "index": 240,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "10",
      "text": "{theme[\"textColor\"]};\n            border-radius: {theme[\"borderRadius\"]};\n            border: none;\n            margin-right: 5px;\n            padding: 0.5rem 1rem;\n            font-weight: 500;\n        }}\n        \n        button[role=\"tab\"][aria-selected=\"true\"] {{\n            background-color: {theme[\"primaryColor\"]}20;\n            color: {theme[\"primaryColor\"]};\n            border-bottom: 2px solid {theme[\"primaryColor\"]};\n        }}\n        \n        button[role=\"tab\"]:hover {{\n            background-color: {theme[\"primaryColor\"]}10;\n        }}\n        \n        /* Input fields */\n        .stTextInput > div > div > input {{\n            color: {theme[\"textColor\"]};\n            border-radius: {theme[\"borderRadius\"]};\n            border: 1px solid rgba(0,0,0,0.1);"
    },
    {
      "index": 241,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "11",
      "text": "border-radius: {theme[\"borderRadius\"]};\n            border: 1px solid rgba(0,0,0,0.1);\n            padding: 0.5rem;\n            background-color: {theme[\"backgroundColor\"]};\n        }}\n        \n        .stTextInput > div > div > input:focus {{\n            border-color: {theme[\"primaryColor\"]};\n            box-shadow: 0 0 0 2px {theme[\"primaryColor\"]}40;\n        }}\n        \n        /* Data frames */\n        .stDataFrame {{\n            color: {theme[\"textColor\"]};\n            border-radius: {theme[\"borderRadius\"]};\n            overflow: hidden;\n        }}\n        \n        .stDataFrame td {{\n            padding: 0.5rem 1rem !important;\n        }}\n        \n        .stDataFrame thead tr th {{\n            background-color: {theme[\"primaryColor\"]}20 !important;"
    },
    {
      "index": 242,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "12",
      "text": ".stDataFrame thead tr th {{\n            background-color: {theme[\"primaryColor\"]}20 !important;\n            color: {theme[\"primaryColor\"]} !important;\n            font-weight: 600 !important;\n        }}\n        \n        .stDataFrame tbody tr:nth-child(even) {{\n            background-color: {theme[\"secondaryBackgroundColor\"]};\n        }}\n        \n        /* Markdown text */\n        div[data-testid=\"stMarkdownContainer\"] {{\n            color: {theme[\"textColor\"]};\n            line-height: 1.6;\n        }}\n        \n        /* Code blocks */\n        code {{\n            color: {theme[\"primaryColor\"]};\n            background-color: {theme[\"secondaryBackgroundColor\"]};\n            padding: 0.2rem 0.4rem;\n            border-radius: 4px;\n            font-size: 0.9em;\n        }}"
    },
    {
      "index": 243,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "13",
      "text": "g: 0.2rem 0.4rem;\n            border-radius: 4px;\n            font-size: 0.9em;\n        }}\n        \n        /* Plot styling */\n        .stPlotlyChart {{\n            background-color: {theme[\"backgroundColor\"]};\n            border-radius: {theme[\"borderRadius\"]};\n            box-shadow: {theme[\"boxShadow\"]};\n            padding: 1rem;\n            border: 1px solid rgba(0,0,0,0.03);\n        }}\n        \n        /* Progress bars */\n        div[data-testid=\"stDecoration\"] {{\n            background-color: {theme[\"primaryColor\"]};\n        }}\n        \n        /* Chat messages */\n        div[data-testid=\"stChatMessage\"] {{\n            background-color: {theme[\"secondaryBackgroundColor\"]};\n            color: {theme[\"textColor\"]};\n            border-radius: {theme[\"borderRadius\"]};"
    },
    {
      "index": 244,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "14",
      "text": "or\"]};\n            color: {theme[\"textColor\"]};\n            border-radius: {theme[\"borderRadius\"]};\n            padding: 0.75rem 1rem;\n            margin-bottom: 0.75rem;\n            box-shadow: {theme[\"boxShadow\"]};\n        }}\n        \n        /* User chat bubble */\n        div[data-testid=\"stChatMessage\"][data-testid=\"user\"] {{\n            background-color: {theme[\"primaryColor\"]}20;\n            border-left: 3px solid {theme[\"primaryColor\"]};\n        }}\n        \n        /* Expandable sections */\n        div[data-testid=\"stExpander\"] {{\n            background-color: {theme[\"secondaryBackgroundColor\"]};\n            border-radius: {theme[\"borderRadius\"]};\n            border: 1px solid rgba(0,0,0,0.05);\n            overflow: hidden;\n        }}\n        \n        /* Expander header */"
    },
    {
      "index": 245,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "15",
      "text": "d rgba(0,0,0,0.05);\n            overflow: hidden;\n        }}\n        \n        /* Expander header */\n        .streamlit-expanderHeader {{\n            background-color: {theme[\"secondaryBackgroundColor\"]};\n            color: {theme[\"primaryColor\"]};\n            font-weight: 500;\n            padding: 0.75rem 1rem;\n        }}\n        \n        /* Expander content */\n        .streamlit-expanderContent {{\n            background-color: {theme[\"secondaryBackgroundColor\"]};\n            padding: 1rem;\n            border-top: 1px solid rgba(0,0,0,0.05);\n        }}\n        \n        /* Slider */\n        div[data-testid=\"stSlider\"] > div > div > div {{\n            background-color: {theme[\"primaryColor\"]};\n        }}\n        \n        /* Alerts and messages */\n        div[data-baseweb=\"notification\"] {{"
    },
    {
      "index": 246,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "16",
      "text": ";\n        }}\n        \n        /* Alerts and messages */\n        div[data-baseweb=\"notification\"] {{\n            background-color: {theme[\"secondaryBackgroundColor\"]};\n            border-radius: {theme[\"borderRadius\"]};\n            border-left: 4px solid {theme[\"primaryColor\"]};\n            color: {theme[\"textColor\"]};\n            box-shadow: {theme[\"boxShadow\"]};\n        }}\n        \n        /* Success messages */\n        div[data-baseweb=\"notification\"][kind=\"positive\"] {{\n            border-left-color: #4CAF50;\n        }}\n        \n        /* Warning messages */\n        div[data-baseweb=\"notification\"][kind=\"warning\"] {{\n            border-left-color: #FF9800;\n        }}\n        \n        /* Error messages */\n        div[data-baseweb=\"notification\"][kind=\"negative\"] {{"
    },
    {
      "index": 247,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "17",
      "text": "/* Error messages */\n        div[data-baseweb=\"notification\"][kind=\"negative\"] {{\n            border-left-color: #F44336;\n        }}\n        \n        /* File uploader */\n        button[data-testid=\"stFileUploadDropzone\"] {{\n            border: 2px dashed rgba(0,0,0,0.1);\n            border-radius: {theme[\"borderRadius\"]};\n            padding: 1rem;\n            background-color: {theme[\"secondaryBackgroundColor\"]};\n            color: {theme[\"textColor\"]};\n            transition: all 0.2s ease;\n        }}\n        \n        button[data-testid=\"stFileUploadDropzone\"]:hover {{\n            border-color: {theme[\"primaryColor\"]};\n            background-color: {theme[\"secondaryBackgroundColor\"]};\n        }}\n    </style>\n    \"\"\", unsafe_allow_html=True)"
    },
    {
      "index": 248,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "18",
      "text": "lor: {theme[\"secondaryBackgroundColor\"]};\n        }}\n    </style>\n    \"\"\", unsafe_allow_html=True)\n\ndef theme_selector():\n    \"\"\"\n    Create an enhanced theme selection dropdown in the sidebar\n    \"\"\"\n    # Initialize session state for theme if it doesn't exist\n    if \"theme\" not in st.session_state:\n        st.session_state.theme = \"Professional\"\n    \n    st.sidebar.markdown(\"### üé® Appearance\")\n    \n    # Theme selector with enhanced styling\n    col1, col2 = st.sidebar.columns([3, 1])\n    \n    with col1:\n        selected_theme = st.selectbox(\n            \"Select Theme\",\n            list(THEMES.keys()),\n            index=list(THEMES.keys()).index(st.session_state.theme),\n            key=\"theme_selector\"\n        )\n    \n    # Preview color for the selected theme\n    with col2:"
    },
    {
      "index": 249,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "19",
      "text": "key=\"theme_selector\"\n        )\n    \n    # Preview color for the selected theme\n    with col2:\n        st.markdown(\n            f\"\"\"\n            <div style=\"\n                width: 30px;\n                height: 30px;\n                border-radius: 50%;\n                background-color: {THEMES[selected_theme]['primaryColor']};\n                margin-top: 25px;\n                box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n            \"></div>\n            \"\"\",\n            unsafe_allow_html=True\n        )\n    \n    # Theme description based on selection\n    theme_descriptions = {\n        \"Professional\": \"Clean and modern look for business applications.\",\n        \"Dark Pro\": \"Sleek dark theme with purple accents.\",\n        \"Midnight Blue\": \"Dark blue theme inspired by developer environments.\","
    },
    {
      "index": 250,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "20",
      "text": "h purple accents.\",\n        \"Midnight Blue\": \"Dark blue theme inspired by developer environments.\",\n        \"Ocean Breeze\": \"Light and refreshing aqua-themed design.\",\n        \"Sunset Horizon\": \"Warm color palette with orange accents.\",\n        \"Minimal Elegance\": \"Subtle and refined neutral design.\",\n        \"Forest Green\": \"Nature-inspired theme with calming green tones.\",\n        \"Corporate Purple\": \"Professional theme with purple elements.\"\n    }\n    \n    st.sidebar.caption(theme_descriptions[selected_theme])\n    \n    # Update theme if changed\n    if selected_theme != st.session_state.theme:\n        st.session_state.theme = selected_theme\n        st.rerun()  # Rerun to apply new theme\n        \n# Demo usage example\ndef theme_preview():"
    },
    {
      "index": 251,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "21",
      "text": "e\n        st.rerun()  # Rerun to apply new theme\n        \n# Demo usage example\ndef theme_preview():\n    \"\"\"Optional function to preview theme elements\"\"\"\n    theme = THEMES[st.session_state.get(\"theme\", \"Professional\")]\n    \n    st.markdown(f\"\"\"\n    <div style=\"\n        background-color: {theme['primaryColor']}; \n        color: white; \n        padding: 1rem; \n        border-radius: {theme['borderRadius']}; \n        margin-bottom: 1rem;\n        box-shadow: {theme['boxShadow']};\n    \">\n        <h2 style=\"margin:0; color: white;\">Current Theme: {st.session_state.get(\"theme\", \"Professional\")}</h2>\n    </div>\n    \"\"\", unsafe_allow_html=True)\n    \n    st.markdown(\"### Theme Preview\")\n    \n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        st.markdown(f\"\"\""
    },
    {
      "index": 252,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "22",
      "text": "me Preview\")\n    \n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        st.markdown(f\"\"\"\n        <div class=\"metric-card\">\n            <h3 style=\"margin-top:0;\">Primary Color</h3>\n            <div style=\"\n                width: 100%;\n                height: 30px;\n                background-color: {theme['primaryColor']};\n                border-radius: 4px;\n            \"></div>\n            <p style=\"margin-bottom:0;\">{theme['primaryColor']}</p>\n        </div>\n        \"\"\", unsafe_allow_html=True)\n    \n    with col2:\n        st.markdown(f\"\"\"\n        <div class=\"metric-card\">\n            <h3 style=\"margin-top:0;\">Background</h3>\n            <div style=\"\n                width: 100%;\n                height: 30px;\n                background-color: {theme['backgroundColor']};"
    },
    {
      "index": 253,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "23",
      "text": ": 100%;\n                height: 30px;\n                background-color: {theme['backgroundColor']};\n                border-radius: 4px;\n                border: 1px solid rgba(0,0,0,0.1);\n            \"></div>\n            <p style=\"margin-bottom:0;\">{theme['backgroundColor']}</p>\n        </div>\n        \"\"\", unsafe_allow_html=True)\n    \n    with col3:\n        st.markdown(f\"\"\"\n        <div class=\"metric-card\">\n            <h3 style=\"margin-top:0;\">Secondary BG</h3>\n            <div style=\"\n                width: 100%;\n                height: 30px;\n                background-color: {theme['secondaryBackgroundColor']};\n                border-radius: 4px;\n                border: 1px solid rgba(0,0,0,0.1);\n            \"></div>"
    },
    {
      "index": 254,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "24",
      "text": "border-radius: 4px;\n                border: 1px solid rgba(0,0,0,0.1);\n            \"></div>\n            <p style=\"margin-bottom:0;\">{theme['secondaryBackgroundColor']}</p>\n        </div>\n        \"\"\", unsafe_allow_html=True)"
    },
    {
      "index": 255,
      "filename": "theme_manager.py",
      "filepath": "ChatIQ-main\\theme_manager.py",
      "chunk_index": "25",
      "text": "ttom:0;\">{theme['secondaryBackgroundColor']}</p>\n        </div>\n        \"\"\", unsafe_allow_html=True)"
    }
  ]
}